#!/bin/sh -e
# vim:se sw=2 ts=2 sts=2 et ai tw=78:
#
# This script creates a filesystem image file in which LUKS encrypted data is
# stored.  This is aimed to store sensitive data securely with remote host
# service such as rsync.net using bss.
#
# See /usr/share/doc/bss/examples/README.md
#
# common shell code
USRBIN="$(realpath "${0%/*}/.")" # /usr/bin
. "${USRBIN%/*}/share/bss/common.sh"
### VARIABLES ###
PROG_NAME="${0##*/}"
# set mode
SECRET_TOOL="YES"
SIZE_DISK="16G"

BSS_LOGGER=0
BSS_LOGGER_LEVEL="2"
# rsync source path name for use by "bss copy" for untrusted remote backup
# directory name to place encrypted disk image
XRSYNC="rsync"
# device mapper target name
XSECRET="secret"
### FUNCTIONS ###
__help () {
cat << END_OF_HELP
Usage: ${PROG_NAME} [-r RSYNC|-s SECRET] [-l|-a] [n [size]|m|g|u|a]

'$PROG_NAME' helps to create and update LUKS encrypted disk image.

OPTION:

  -r RSYNC      use '~/RSYNC/' insted of '~/rsync/' to place the LUKS
                encrypted disk image file.

  -s SECRET     use '~/rsync/SECRET.img' insted of '~/rsync/secret.img' for
                the LUKS encrypted disk image file.

  -l, --logger  use journald to record log (useful for systemd timer service)

  -a, --ask     ask passphrase to unlock LUKS encryption (Unless this is set,
                GNOME secret-tool is used to obtain passphrase)

COMMAND:

Multiple commands may be specified to execute them in sequence.

  new [size]    make a new sparse disk image '~/rsync/secret.img' formatted as
                ext4 filesystem on LUKS encrypted volume. The size can be
                optionally specified, e.g. as '32G'
  mount         decrypt the LUKS disk image '~/rsync/secret.img' to create a
                device-mapper device '/dev/device-mapper/secret', then
                mount it onto '~/rsync/secret.mnt'
  gather        run 'bss gather ~/secret.mnt/'
  umount        umount the device-mapper device '/dev/device-mapper/secret'
                from '~/secret.mnt/' and close it
  all           perform all actions: mount -> gather -> umount -> close

These commands may be shortened if they aren't ambiguous.

See /usr/share/doc/bss/examples/README.md or
      https://github.com/osamuaoki/bss/tree/main/examples

Copyright 2023 Osamu Aoki <osamu@debian.org>, GPL 2+
END_OF_HELP
}
__version () {
cat << EOM
$PROG_NAME ($BSS_VERSION)

Copyright (C) 2023 Osamu Aoki <osamu@debian.org>

License GPLv2+: GNU GPL version 2 or later
<https://gnu.org/licenses/gpl-2.0.html>.  This is free software: you are free
to change and redistribute it.  There is NO WARRANTY, to the extent permitted
by law.

Written by Osamu Aoki.
EOM
}

open_luks () {
  __echo 2 "I: unlock LUKS disk image $DISK_IMAGE as $DEV_MAPPER_PATH"
  if [ "$SECRET_TOOL" = "YES" ]; then
    secret-tool lookup LUKS "$DISK_IMAGE" | \
      sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
  else
    sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
  fi
}

close_luks () {
  __echo 2 "I: cryptsetup close disk image at $XSECRET ..."
  if sudo cryptsetup close "$XSECRET" ; then
    __echo 2 "I: cryptsetup close disk image at $XSECRET done"
  else
    __echo 2 "I: cryptsetup close disk image at $XSECRET with error"
  fi
}

new_secret () {
  if [ -e "$DISK_IMAGE" ]; then
    __echo 0 "E: disk image already exists: $DISK_IMAGE"
    exit $EXIT_ERROR
  fi
  # this is always called from console
  # create a new LUKS disk image formatted with ext4
  if ! secret-tool lookup LUKS "$DISK_IMAGE" >/dev/null ; then
    __echo 2 "I: Setup passphrase for LUKS: $DISK_IMAGE"
    secret-tool store --label="LUKS $DISK_IMAGE" LUKS "$DISK_IMAGE"
  else
    __echo 2 "I: Passphrase for LUKS aleady stored: $DISK_IMAGE"
  fi
  __echo 2 "I: create $SIZE_DISK image: $DISK_IMAGE"
  fallocate -l "$SIZE_DISK" "$DISK_IMAGE"
  __echo 2 "I: create LUKS in $DISK_IMAGE"
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    cryptsetup luksFormat "$DISK_IMAGE" -
  __echo 2 "I: open LUKS as $DEV_MAPPER_PATH"
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
  __echo 2 "I: create btrfs in $DEV_MAPPER_PATH"
  sudo mkfs.ext4 -L "$XSECRET" "$DEV_MAPPER_PATH"
  __echo 2 "I: mount $DEV_MAPPER_PATH on $MNT_PATH"
  sudo mount "$DEV_MAPPER_PATH" "$MNT_PATH"
  __echo 2 "I: set $MNT_PATH to UID:GID=1000:1000"
  sudo chown "1000:1000" "$MNT_PATH"
  {
    echo "# This file lists files and directories to be gathered"
    echo "# ----- Files -----"
    echo ".bashrc"
    echo "# ----- Directories -----"
    echo ".gnupg"
    echo ".ssh"
  } > "$MNT_PATH/.gatherrc"
  __echo 2 "I: create .gatherrc"
  bss template "$MNT_PATH"
  __echo 2 "I: create .bss.d/.bss.conf"
  close_luks
}

mount_secret () {
  if [ ! -e "$DISK_IMAGE" ]; then
    __echo 0 "E: disk image missing: $DISK_IMAGE"
    __echo 2 "I: create disk image interactively as: '$PROG_NAME new [size]'"
    exit $EXIT_ERROR
  fi
  # mount if not mounted
  if mount|grep -e "$MNT_PATH" >/dev/null; then
    __echo 2 "I: skip mounting:   $DEV_MAPPER_PATH on $MNT_PATH"
    __echo 2 "I: already mounted: $(mount|grep -e "$MNT_PATH"|sed 's/type.*$//')"
  else
    open_luks
    __echo 2 "I: mount $DEV_MAPPER_PATH on $MNT_PATH"
    sudo mount "$DEV_MAPPER_PATH" "$MNT_PATH"
  fi
  __echo 2 "I: disk image usage (size used avail use%): $(df -h "$MNT_PATH" \
    | grep "$MNT_PATH" \
    | sed -e 's/\s\s*/ /g' \
    | cut -d' ' -f 2-5)"
}

gather_secret () {
  bss gather "$MNT_PATH"
}

unmount_secret () {
  sync
  # Just after mount, somehow its device is busy to prevent umount
  # this may be due to Gnome Files etc.
  sleep 1
  sync
  __echo 2 "I: umount disk image at: $MNT_PATH ..."
  # use umount w/o -l to be on safe side.
  if sudo umount "$MNT_PATH" ; then
    __echo 2 "I: umount disk image at: $MNT_PATH done"
  else
    __echo 2 "I: umount disk image at: $MNT_PATH with error"
  fi
  close_luks
}

##############################################################################
### MAIN ###
##############################################################################
# Parse Command Line
##############################################################################
# The quotes around "$@" are essential!
# We need TEMP as the 'eval set --' would nuke the return value of getopt.
TEMP=$(getopt -o 'r:s:lanqvxh' -n "${PROG_NAME}" \
  --long 'rsync:,secret:,logger,ask:,noop,quiet,version,verbose,trace,help' -- "$@")
# Note the quotes around "$TEMP": they are essential!
#__echo 3 "D: DEBUG: ***** TEMP='$TEMP'"
eval set -- "$TEMP"
unset TEMP
# OPTIONS
while [ -n "$1" ]; do
  case "$1" in
    -r|--rsync)
      shift
      XRSYNC="${1:-rsync}"
      shift
      ;;
    -s|--secret)
      shift
      XSECRET="${1:-secret}"
      shift
      ;;
    -l|--log*)
      BSS_LOGGER=1
      ;;
    -a|--ask)
      SECRET_TOOL="NO"
      ;;
    -n|--noop)
      NOOP="__echo 2 __" # ANY non ""
      ;;
    -q|--quiet)
      BSS_LOGGER_LEVEL=1
      ;;
    --version)
      __version
      exit $EXIT_SUCCESS
      ;;
    -v|--verbose)
      BSS_LOGGER_LEVEL=$((BSS_LOGGER_LEVEL+1))
      ;;
    -x|--trace)
      SETX_ON="set -x"
      SETX_OFF="set +x"
      ;;
    -h|--help)
      __help
      exit $EXIT_SUCCESS
      ;;
    '--')
      shift
      break
    ;;
    -*)
      __echo 0 "E: Unknown option: '$1'"
      __help
      exit $EXIT_ERROR
    ;;
    *)
      # command
      break
    ;;
  esac
  shift
done

##############################################################################
# mount point for decrypted disk image: ~/secret.mnt
MNT_PATH="$HOME/$XSECRET.mnt"
mkdir -p "$MNT_PATH"
# device mapper path
DEV_MAPPER_PATH="/dev/mapper/$XSECRET"
# encrypted disk image file path: ~/rsync/secret.img
DISK_IMAGE="$HOME/$XRSYNC/$XSECRET.img"
# update parameters for -c
$SETX_ON
if [ "$BSS_LOGGER_LEVEL" -ge 3 ]; then
  VERBOSE="-v"
fi
if [ "$BSS_LOGGER" = "1" ]; then
  case $BSS_LOGGER_LEVEL in
    0) LOGGER="systemd-cat -p 3 -t luksimg"
      ;;
    1) LOGGER="systemd-cat -p 4 -t luksimg"
      ;;
    2) LOGGER="systemd-cat -p 5 -t luksimg"
      ;;
    3) LOGGER="systemd-cat -p 6 -t luksimg"
      ;;
    4|5|6|7) LOGGER="systemd-cat -p 7 -t luksimg"
      ;;
  esac
else
  LOGGER=""
fi

##############################################################################
# "new" should be run alone and from console
case "$1" in
  n*) # new
    shift
    if [ -n "$1" ];then
      SIZE_DISK="$1"
    fi
    new_secret
    exit $EXIT_SUCESS
    ;;
esac

##############################################################################
# no command -- help
if [ -z "$1" ]; then
      __help
      exit $EXIT_SUCCESS
fi

##############################################################################
# command sequence
while [ -n "$1" ]; do
  case "$1" in
    m*) # mount
      shift
      mount_secret
      ;;
    g*) # gather files
      shift
      gather_secret
      ;;
    u*) # umount secret folder
      shift
      unmount_secret
      ;;
    o*) # open luks -- not public
      shift
      open_luks
      ;;
    c*) # close luks -- not public
      shift
      close_luks
      ;;
    a*) # all
      shift
      mount_secret
      gather_secret
      unmount_secret
      close_luks
      ;;
    *)
      __help
      exit $EXIT_ERROR
      ;;
  esac
done
exit $EXIT_SUCCESS
#########################################################################################################################
