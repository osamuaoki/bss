#!/bin/sh -e
# vim:se sw=2 ts=2 sts=2 et ai tw=78:
#
# This script creates a filesystem image file in which LUKS encrypted data is
# stored.  This is aimed to store sensitive data securely with remote host
# service such as rsync.net using bss.
#
# See /usr/share/doc/bss/examples/README.md
#
# common shell code
USRBIN="$(realpath "${0%/*}/.")" # /usr/bin
. "${USRBIN%/*}/share/bss/common.sh"
### VARIABLES ###
PROG_NAME="${0##*/}"
# set mode
ECHO="echo"
SECRET_TOOL="YES"
SIZE_DISK="16G"

BSS_LOGGER=0
BSS_LOGGER_LEVEL="2"
# rsync source path name for use by "bss copy" for untrusted remote backup
# directory name to place encrypted disk image
XRSYNC="rsync"
# device mapper target name
XSECRET="secret"
### FUNCTIONS ###
__help () {
cat << END_OF_HELP
Usage: ${PROG_NAME} [-r RSYNC|-s SECRET] [-l|-a] [n [size]|o|m|b|u|c|a]

"$PROG_NAME" helps to create and update LUKS encrypted disk image.

OPTION:

-r RSYNC        use '~/RSYNC/' insted of '~/rsync/' to place the
                LUKS encrypted disk image file.

-s SECRET       use '~/rsync/SECRET.img' insted of '~/rsync/secret.img'
                for the LUKS encrypted disk image file.

-l, --logger    use journald to record log (useful for systemd timer service)

-a, --ask       ask passphrase to unlock LUKS encryption (Unless this is set,
                GNOME secret-tool is used to obtain passphrase)

COMMAND:

Multiple commands may be specified to execute them in sequence.

new [size]:
        make a new sparse disk image '~/rsync/secret.img' formatted as
        ext4 filesystem on LUKS encrypted volume. The size can be
        optionally specified, e.g. as '32G'
open:   decrypt the LUKS disk image '~/rsync/secret.img' to create a
        device-mapper device '/dev/device-mapper/secret'
mount:  mount the device-mapper device '/dev/device-mapper/secret' onto
        '~/rsync/secret.mnt'
backup: backup files specified in '~/.secretrc' to '~/secret.mnt/'
umount: umount the device-mapper device '/dev/device-mapper/secret'
        from '~/secret.mnt/'
close:  close the device-mapper device '/dev/device-mapper/secret'
all:    perform all actions: open -> mount -> backup -> umount -> close

These commands may be shortened if they aren't ambiguous.

See /usr/share/doc/bss/examples/README.md or
    https://github.com/osamuaoki/bss/tree/main/examples

Copyright 2023 Osamu Aoki <osamu@debian.org>, GPL 2+
END_OF_HELP
}
__version () {
cat << EOM
$PROG_NAME ($BSS_VERSION)

Copyright (C) 2023 Osamu Aoki <osamu@debian.org>

License GPLv2+: GNU GPL version 2 or later
<https://gnu.org/licenses/gpl-2.0.html>.  This is free software: you are free
to change and redistribute it.  There is NO WARRANTY, to the extent permitted
by law.

Written by Osamu Aoki.
EOM
}
__new_disk_image () {
  # this is always called from console
  # create a new LUKS disk image formatted with ext4
  if ! secret-tool lookup LUKS "$DISK_IMAGE" >/dev/null ; then
    echo "I: Setup passphrase for LUKS: $DISK_IMAGE" >&2
    secret-tool store --label="LUKS $DISK_IMAGE" LUKS "$DISK_IMAGE"
  else
    echo "I: Passphrase for LUKS aleady stored: $DISK_IMAGE" >&2
  fi
  echo "I: create $SIZE_DISK image: $DISK_IMAGE" >&2
  fallocate -l "$SIZE_DISK" "$DISK_IMAGE"
  echo "I: create LUKS in $DISK_IMAGE" >&2
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    cryptsetup luksFormat "$DISK_IMAGE" -
  echo "I: open LUKS as $DEV_MAPPER_PATH" >&2
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
  echo "I: create btrfs in $DEV_MAPPER_PATH" >&2
  sudo mkfs.ext4 -L "$XSECRET" "$DEV_MAPPER_PATH"
  echo "I: mount $DEV_MAPPER_PATH on $MNT_PATH"
  sudo mount "$DEV_MAPPER_PATH" "$MNT_PATH"
  echo "I: set $MNT_PATH to UID:GID=1000:1000" >&2
  sudo chown "1000:1000" "$MNT_PATH"
  {
    echo "!!! Don't use this ~/$MNT_PATH/ as working directory        !!!"
    echo "!!! $PROG_NAME copies files listed in ~/$CONF_PATH into here !!!"
  } > "$MNT_PATH/00_DO_NOT_USE_THIS_AS_WORKING_DIRECTORY"
}
new_secret () {
  # this is always called from console
  # create a new luks disk image with ext4
  if ! secret-tool lookup LUKS "$DISK_IMAGE" >/dev/null ; then
    echo "I: Setup passphrase for LUKS: $DISK_IMAGE" >&2
    secret-tool store --label="LUKS $DISK_IMAGE" LUKS "$DISK_IMAGE"
  else
    echo "I: Passphrase for LUKS aleady stored: $DISK_IMAGE" >&2
  fi
  echo "I: create $SIZE_DISK image: $DISK_IMAGE" >&2
  fallocate -l "$SIZE_DISK" "$DISK_IMAGE"
  echo "I: create LUKS in $DISK_IMAGE" >&2
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    cryptsetup luksFormat "$DISK_IMAGE" -
  echo "I: open LUKS as $DEV_MAPPER_PATH" >&2
  secret-tool lookup LUKS "$DISK_IMAGE" | \
    sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
  echo "I: create btrfs in $DEV_MAPPER_PATH" >&2
  sudo mkfs.ext4 -L "$XSECRET" "$DEV_MAPPER_PATH"
  echo "I: mount $DEV_MAPPER_PATH on $MNT_PATH"
  sudo mount "$DEV_MAPPER_PATH" "$MNT_PATH"
  echo "I: set $MNT_PATH to UID:GID=1000:1000" >&2
  sudo chown "1000:1000" "$MNT_PATH"
  {
    echo "!!! Don't use this ~/$MNT_PATH/ as working directory        !!!"
    echo "!!! $PROG_NAME copies files listed in ~/$CONF_PATH into here !!!"
  } > "$MNT_PATH/00_DO_NOT_USE_THIS_AS_WORKING_DIRECTORY"
}

mount_secret () {
  if [ ! -e "$DISK_IMAGE" ]; then
    $ECHO "E: disk image missing: $DISK_IMAGE"
    $ECHO "I: create disk image interactively as: $PROG_NAME new [size]"
    exit $EXIT_ERROR
  fi
  # let's mount
  if mount|grep -e "$MNT_PATH" >/dev/null; then
    $ECHO "I: skip mounting:   $DEV_MAPPER_PATH on $MNT_PATH"
    $ECHO "I: already mounted: $(mount|grep -e "$MNT_PATH"|sed 's/type.*$//')"
  else
    $ECHO "I: unlock LUKS disk image $DISK_IMAGE as $DEV_MAPPER_PATH"
    if [ "$SECRET_TOOL" = "YES" ]; then
      secret-tool lookup LUKS "$DISK_IMAGE" | \
        sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
    else
      sudo cryptsetup open "$DISK_IMAGE" "$XSECRET" --type luks
    fi
    $ECHO "I: mount $DEV_MAPPER_PATH on $MNT_PATH"
    sudo mount "$DEV_MAPPER_PATH" "$MNT_PATH"
  fi
  $ECHO "I: disk image usage (size used avail use%): $(df -h "$MNT_PATH" \
    | grep "$MNT_PATH" \
    | sed -e 's/\s\s*/ /g' \
    | cut -d' ' -f 2-5)"
}

backup_secret () {
  if [ ! -e "$MNT_PATH" ]; then
    $ECHO "E: backup destination directory missing: $MNT_PATH"
    exit $EXIT_ERROR
  fi
  $ECHO "I: back up to $MNT_PATH"
  while read -r F ; do
    # remove tailing / if exists
    F="${F%/}"
    if [ "${F}" = "${F#/}" ] ; then
      # relative path
      BACKUP="relative_path/"
    else
      # absolute path
      BACKUP="absolute_path"
    fi
    D="$(dirname "$F")"
    if [ "$D" = "." ]; then
      D=""
    elif [ "$D" = "/" ]; then
      D="/"
    elif [ "$D" = ".." ]; then
      $ECHO "E: don't use .. as a part of relative path"
      exit $EXIT_ERROR
    else
      D="$D/"
    fi
    # all local transfer no-need to be verbose
    # shell wild card allowed for $F, cwd=$HOME
    mkdir -p "$MNT_PATH/${BACKUP}$D"
    $ECHO "rsync -axHS --delete $F $MNT_PATH/${BACKUP}$D"
    sudo rsync -axHS --delete $F "$MNT_PATH/${BACKUP}$D"
  done
}

unmount_secret () {
  sync
  # Just after mount, somehow its device is busy to prevent umount
  # this may be due to Gnome Files etc.
  sleep 1
  sync
  $ECHO "I: umount disk image at: $MNT_PATH ..."
  # use umount w/o -l to be on safe side.
  if sudo umount "$MNT_PATH" ; then
    $ECHO "I: umount disk image at: $MNT_PATH done"
  else
    $ECHO "I: umount disk image at: $MNT_PATH with error"
  fi
}

close_luks () {
  $ECHO "I: cryptsetup close disk image at $XSECRET ..."
  if sudo cryptsetup close "$XSECRET" ; then
    $ECHO "I: cryptsetup close disk image at $XSECRET done"
  else
    $ECHO "I: cryptsetup close disk image at $XSECRET with error"
  fi
}

template_conf () {
  if [ ! -e "$CONF_PATH" ]; then
    # if template configuration file is missing, create it
    cat >"$CONF_PATH" <<EOF
# Edit this to adopt to the system
####################################
# Files to backup (shell glob OK)
.bash_logout
.bashrc
.profile
.bash_aliases
#.bash_fzf_completion
#.bash_fzf_keybindings
.bashrc
.benrc
#.caffrc
#.debrc
.devscripts
.gbp.conf
.gitconfig
#.quiltrc-dpkg
.reportbugrc
.sbuildrc*
#.shellcheckrc
#.config/black
#.config/flake8
#.config/pylintrc
####################################
# directories to backup
Documents
bin
.ssh
.gnupg
.config/autostart
.config/systemd/user
.local/share/keyrings
####################################
# absolute path
/etc
/boot/grub
EOF
  fi
}

##############################################################################
### MAIN ###
##############################################################################
# Parse Command Line
##############################################################################
# The quotes around "$@" are essential!
# We need TEMP as the 'eval set --' would nuke the return value of getopt.
TEMP=$(getopt -o 'r:s:lanqvxh' -n "${PROG_NAME}" \
  --long 'rsync:,secret:,logger,ask:,noop,quiet,version,verbose,trace,help' -- "$@")
# Note the quotes around "$TEMP": they are essential!
#echo "DEBUG: ***** TEMP='$TEMP'"
eval set -- "$TEMP"
unset TEMP
# OPTIONS
while [ -n "$1" ]; do
  case "$1" in
    -r|--rsync)
      shift
      XRSYNC="${1:-rsync}"
      shift
      ;;
    -s|--secret)
      shift
      XSECRET="${1:-secret}"
      shift
      ;;
    -l|--log*)
      BSS_LOGGER=1
      ;;
    -a|--ask)
      SECRET_TOOL="NO"
      ;;
    -n|--noop)
      NOOP="echo __" # ANY non ""
      ;;
    -q|--quiet)
      BSS_LOGGER_LEVEL=1
      ;;
    --version)
      __version
      exit $EXIT_SUCCESS
      ;;
    -v|--verbose)
      BSS_LOGGER_LEVEL=$((BSS_LOGGER_LEVEL+1))
      ;;
    -x|--trace)
      SETX_ON="set -x"
      SETX_OFF="set +x"
      ;;
    -h|--help)
      __help
      exit $EXIT_SUCCESS
      ;;
    '--')
      shift
      break
    ;;
    -*)
      echo "E: Unknown option: '$1'" >&2
      __help
      exit $EXIT_ERROR
    ;;
    *)
      # command
      break
    ;;
  esac
  shift
done

# mount point for decrypted disk image: ~/secret.mnt
MNT_PATH="$HOME/$XSECRET.mnt"
mkdir -p "$MNT_PATH"
# device mapper path
DEV_MAPPER_PATH="/dev/mapper/$XSECRET"
# config path: ~/.secretrc
CONF_PATH="$HOME/.${XSECRET}rc"
template_conf
# encrypted disk image file path: ~/rsync/secret.img
DISK_IMAGE="$HOME/$XRSYNC/$XSECRET.img"
# update parameters for -c
$SETX_ON
if [ "$BSS_LOGGER_LEVEL" -ge 3 ]; then
  VERBOSE="-v"
fi
if [ "$BSS_LOGGER" = "1" ]; then
  case $BSS_LOGGER_LEVEL in
    0) LOGGER="systemd-cat -p 3 -t bss"
      ;;
    1) LOGGER="systemd-cat -p 4 -t bss"
      ;;
    2) LOGGER="systemd-cat -p 5 -t bss"
      ;;
    3) LOGGER="systemd-cat -p 6 -t bss"
      ;;
    4|5|6|7) LOGGER="systemd-cat -p 7 -t bss"
      ;;
  esac
else
  LOGGER=""
fi

#########################################################################################################################
# "new" should be run alone and from console
case "$1" in
  n*) # new
    shift
    if [ -n "$1" ];then
      SIZE_DISK="$1"
    fi
    new_secret
    exit $EXIT_SUCESS
    ;;
esac

#########################################################################################################################
# no command -- help
if [ -z "$1" ]; then
      help
      exit $EXIT_SUCCESS
fi

#########################################################################################################################
# command sequence
while [ -n "$1" ]; do
  case "$1" in
    m*) # mount
      shift
      mount_secret
      ;;
    b*) # backup to secret folder
      shift
      grep -v "^#" "$CONF_PATH" | backup_secret
      ;;
    c*) # close luks -- not public
      shift
      close_luks
      ;;
    u*) # umount secret folder
      shift
      unmount_secret
      close_luks
      ;;
    o*) # one go
      shift
      mount_secret
      grep -v "^#" "$CONF_PATH" | backup_secret
      unmount_secret
      close_luks
      ;;
    *)
      help
      exit $EXIT_ERROR
      ;;
  esac
done
exit $EXIT_SUCCESS
#########################################################################################################################
