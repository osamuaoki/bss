#!/bin/sh -e
## @brief btrfs subvolume snapshot utility
# vim:set ai si sts=2 sw=2 et:
# shellcheck disable=SC2004
# -- SC2004 disable globally due to dash weiredness
##############################################################################
# Copyright 2022 (C) Osamu Aoki <osamu@debian.org>
# License: GPL 2+
##############################################################################
BSS_VERSION="1.1.2"

EXIT_SUCCESS=0
EXIT_ERROR=1

__help () {
cat << END_OF_HELP
Usage: $BSS [OPTIONS] SUBCOMMAND [PATH [[ARG]...]

"$BSS" is basically a "btrfs subvolume ..." command wrapper to create and
process historical snapshots with the intuitive snapshot subvolume name and
flexible data aging capabilities.

"$BSS" operates on the btrfs subvolume pointed by the first optional argument
PATH.  PATH can point to anywhere within this source btrfs subvolume.  The
default value for PATH is the current directory (".").  The internal variable
"\$FS_BASE" is the BASE directory of this source btrfs subvolume.

"$BSS snapshot [PATH]" starts "snapshot" operation to create a btrfs readonly
snapshot of the source btrfs subvolume using "btrfs subvolume snapshot -r ...".
The snapshot subvolume is named with ISO 8601 timestamp and TYPE specifier,
e.g.  '2020-09-02T11:51:50+00:00.single' and placed normally in the "$BSS_DIR/"
directory relative to the BASE directory.  This normal mode is intended to be
used for the user data.

"$BSS snapshot [PATH]" can place its snapshots under the "BSS_SNAP_DEST"
directory specified in "$BSS_CONF".  Normally, it is set to the null string to
indicate "$BSS" to use the normal mode.  This "BSS_SNAP_DEST" directory must be
on the same btrfs but it can be outside of the snapshot source subvolume.  This
system mode is intended to be used for the root filesystem.

"$BSS process [PATH]" starts "process" operation to process existing snapshots
generated by "$BSS" according to their age.  "$BSS" checks the time interval
between them from the older ones to newer ones and makes them more sparse for
the older ones by removing some of them using parameters in "$BSS_CONF" in the
"$BSS_DIR/" directory.  This involves following actions:

  * Secure minimum required free blocks (minimum FMIN %).
  * Keep initial few (NMIN) snapshots unconditionally.
  * Limit the maximum number of snapshots to NMAX.
    * NMAX=0 is the special case and means no limit for number of snapshots.
  * Before TMIN, keep snapshots unconditionally.
  * Age snapshots with basically exponentially growing intervals with the
    specified ratio (STEP 2%-90%).
  * After TMID, age snapshots more aggressively.
    * Special handlings to keep some high priority snapshots stop.
    * If TMID_ACTION=filter, content files of snapshots are filtered with the
      script "$BSS_FLTR" at the "$BSS_DIR/" directory.
  * After TMAX, stop aging snapshots.
    * TMAX=0 is the special case and means no limit for aging.
    * If TMAX_ACTION=drop, drop subvolume after TMAX.
    * If TMAX_ACTION=keep, keep subvolume after TMAX.

OPTIONS:

  -t,--type TYPE  use TYPE instead of the default "single" for the snapshot
                  type.  The automatic snapshot uses "pre" (before APT), "post"
                  (after APT), "hour" (on boot and every hour).
                  If "keep" is specified, the snapshot with it will be
                  kept forever under the normal aging process.
  -c,--conf RC    use "RC.$EXT_CONF" and "RC.$EXT_FLTR" instead of their
                  default "$BSS_CONF" and "$BSS_FLTR"
  -f,--force      force to reapply filter
  -n,--noop       no file nor filesystem modification by prepending pertinent
                  internal commands with "echo __"
  -h,--help       show this help
  --version       show version
  -l,--logger     use systemd logger
  -q,--quiet      quiet (no notice messages, just warn/error messages)
  -v,--verbose    verbose (with info messages)
  -vv             very verbose for debug (with info and debug messages)
  -x              trace on (trace shell code for debug)

SUBCOMMAND:

  snapshot: make a readonly snapshot normally in the relative path "$BSS_DIR/"
            as <ISO_8601_date>.<TYPE>  (The default type is "single")
  overview: overview of all snapshots (wrapper for age)
  process:  process snapshots according to their aging status
  copy:     copy subvolume at the BASE directory (1st argument) to the (remote)
            destination (2nd argument) using rsync
  jobs:     list all systemd timer schedule jobs for $BSS
  list:     list all snapshots
  age:      assess aging status of all snapshots
  base:     print the BASE directory for "$BSS"
  filter:   create a filtered snapshot from the specified snapshot in
            "$BSS_DIR/" as <specified_subvol_name>_filter
  revert:   make snapshot <ISO_8601_date>.last and replace the subvolume at the
            BASE directory (1st argument) with the specified snapshot
            <ISO_8601_date>.<extension> (2nd argument) found under
            "BSS_SNAP_DEST" specified in "$BSS_CONF".  This is only for the
            system mode. (This is alpha stage untested feature.)
  zap:      zap (=delete) particular snapshot(s) specified by the arguments
            "zap" is required to be typed in full text.
  template: make template files in the "$BSS_DIR/" directory:
              "$BSS_CONF" (aging rule)
              "$BSS_FLTR" (filtering rule)

Subcommands may be shortened to a single character.

ARGUMENTS:

For some SUBCOMMANDs, enxtra optional arguments after the explicit PATH may
be specified.

For "$BSS copy", this is a combination of "$BSS snapshot" to create a snapshot
of the BASE directory to SOURCE_PATH and a wrapper for "$RSYNC" command with
its first argument SOURCE_PATH and the second argument DEST_PATH.  This command
is smart enough to skip the "$BSS_DIR/" directory to allow independent
management of data using "$BSS" on both the BASE directory and DEST_PATH. If
DEST_PATH is a local path such as "/srv/backup", then "$RSYNC $RSYNC_OPTA" is
used to save the CPU load.  If DEST_PATH is a remote path such as
"[USER@]HOST:DEST_PATH", then "$RSYNC $RSYNC_OPTR" is used to save the network
load.

For "$BSS zap", the first argument is normally ".".  The following argument
specifies the action which can be:

  * new:        zap (=delete) the newest snapshot subvolume
  * old:        zap the oldest snapshot subvolume
  * half:       zap the older half of snapshot subvolumes
  * <subvolume>â€¦: zap specified snapshot subvolume(s) (path without "$BSS_DIR/")

Unless you have specific reasons to use "$BSS zap", you should consider to use
"$BSS process" to prune outdated snapshots.

For "$BSS" revert PATH PATH_OLD", subvolume at PATH is replaced by the
subvolume at PATH_OLD.  PATH can't be set to "/".

NOTE:

This "$BSS" command comes with examples for systemd scripts and apt hook script
to enable automatic "snapshot" operations.  This "$BSS" command also comes with
examples for systemd scripts to enable automatic daily "process" operation.

For some snapshots, different TYPE values may be used instead of TYPE='single'.

  * TYPE='pre':  automatic "snapshot" operation just before APT update
  * TYPE='post': automatic "snapshot" operation just after  APT update
  * TYPE='copy': automatic "snapshot" operation just before "$BSS copy"
  * TYPE='hour': automatic "snapshot" operation on boot and every hour
  * TYPE='last': automatic "snapshot" operation just before "$BSS revert"

This "$BSS" calculates age related time values in the second and prints them in
the DAYS.HH:MM:SS format (HH=hour, MM=minute, SS=second).

You can make a snapshot just by "$BSS" alone.

You can use verbose "$BSS -v base" command to print current effective
configuration parameters without side effects.

This "$BSS" command uses systemd journal.  You can check recent invocation with:

  $ journalctl -a -b -t bss

CAVEAT:

The source filesystem must be btrfs.

The non-root user who executes this command must be a member of "sudo".

Running filter script "$BSS_FLTR" drains CPU and SSD resources but it may save
SSD usage size significantly.  If you are not interested in reducing SSD usage
size by this script, remove this "$BSS_FLTR" file and set
BSS_TMID_ACTION="no_filter" in "$BSS_CONF".

The "revert" operation is supported only for the system mode.  APT updates can
be used to create snapshots of the system.  The "revert" operation can bring
the system before the APT update operation.  The "revert" operation  must be
performed from the secondary system on another root filesystem and all
subvolumes to be manipulated shouldn't be accessed by other processes. You
should manually mount using "/etc/fstab" for all subvolumes under the subvolume
to run "revert" operation and manage them separately to keep the system
recoverable since the snapshot operation isn't recursive.

Although this "$BSS" focuses on btrfs, there is minimal upport for ext2/ext3
(this includes ext4) for "$BSS copy ..." without using the snapshot. 

Copyright 2022 Osamu Aoki <osamu@debian.org>, GPL 2+
END_OF_HELP
}

__version () {
cat << EOM
$BSS ($BSS_VERSION)

Copyright (C) 2021 Osamu Aoki <osamu@debian.org>

License GPLv2+: GNU GPL version 2 or later
<https://gnu.org/licenses/gpl-2.0.html>.  This is free software: you are free
to change and redistribute it.  There is NO WARRANTY, to the extent permitted
by law.

Written by Osamu Aoki.
EOM

}

#############################################################################
# Constants
#############################################################################
BSS="${0##*/}"
BSS_LOGGER=0
BSS_LOGGER_LEVEL="2"
BSS_DIR=".bss.d"
BSS_TYPE="single" # single, pre, post, hour, ...
EXT_CONF="conf"
EXT_FLTR="fltr"
EXT_COPY_PRE="copy-pre"
EXT_COPY_POST="copy-post"
BSS_STEM=".$BSS"
BSS_CONF="$BSS_STEM.$EXT_CONF"
BSS_FLTR="$BSS_STEM.$EXT_FLTR"
BSS_COPY_PRE="$BSS_STEM.$EXT_COPY_PRE"
BSS_COPY_POST="$BSS_STEM.$EXT_COPY_POST"
NOW_TSTR=$(date -u --iso=second) # time stamp string
NOW_TEPO=$(date +%s -d"$NOW_TSTR") # unix epoch
BSS_NMIN="3"             # minimum items to keep (initial)
BSS_NMAX="0"             # maximum items to keep (0 for no_limit)
BSS_TMAX="60*60*24*1000" # ~3YR    (time to stop aging)
BSS_TMAX_ACTION="keep"   # keep (default) or drop
BSS_TMID="60*60*24*2"    # 2 days (time to actually process snapshots)
BSS_TMID_ACTION="no_filter"  # No filter (it's CPU and SSD consuming)
BSS_TMIN="60*10"         # 10 Min. (time to start aging)
BSS_STEP="20"            # 20 % as aging step
BSS_FMIN="10"            # minimum required free disk % for snapshot
BSS_COPY_DEST=""
BSS_SNAP_DEST=""
BSS_ZAP_ACTIVE="false"
BSS_FORCE=""
NOOP=""
SETX_ON=""
SETX_OFF=""
if [ "$(id -u)" = "0" ]; then
  SUDO=""
else
  if which sudo >/dev/null; then
    SUDO="sudo"
  else
    __echo 0 "Please install 'sudo' and configure it."
    exit $EXIT_ERROR
  fi
fi
BSV="$SUDO btrfs subvolume"
RSYNC="rsync"
# Use readonly snapshot as the rsync source
# Note on rsync options -a == -rlptgoD
# H: hardlink
# x: one filesystem
# S: sparse
# v: verbose
# z: compress

# less cpu load
RSYNC_OPTA="-aHxSv --delete"
# less communication bandwidth
RSYNC_OPTR="-aHxSzv --delete"

#############################################################################
# System Functions (echo and trap)
##############################################################################
# v--- BSS_LOGGER_LEVEL
#   v--- SYSTEMD LOGGER_LEVEL
# 0 3 W:   Err       Print error
# 1 4 W:   Warning   Print warning        (-q)
# 2 5 N:   Notice    Print notice only    (normal)
# 3 6 I:   Info      Print verbose output (-v)
# 4 7 D:   Debug     Print Debug output   (-vv)
__echo () {
  $SETX_OFF
  BSS_MSG_LEVEL="$1"
  shift
  if [ "$BSS_LOGGER_LEVEL" -ge "$BSS_MSG_LEVEL" ]; then
    case $BSS_MSG_LEVEL in
      0) echo "E: $*" >&2
        ;;
      1) echo "W: $*" >&2
        ;;
      2) echo "N: $*" >&2
        ;;
      3) echo "I: $*" >&2
        ;;
      4|5|6|7) echo "D: $*" >&2
        ;;
    esac
    if [ "$BSS_LOGGER" = "1" ]; then
      case $BSS_MSG_LEVEL in
        0) systemd-cat -p 3 -t "bss" echo "$*"
          ;;
        1) systemd-cat -p 4 -t "bss" echo "$*"
          ;;
        2) systemd-cat -p 5 -t "bss" echo "$*"
          ;;
        3) systemd-cat -p 6 -t "bss" echo "$*"
          ;;
        4|5|6|7) systemd-cat -p 7 -t "bss" echo "$*"
          ;;
      esac
    fi
  fi
  $SETX_ON
}

# traps
__term_exit () {
  __echo 0 "Process externally interrupted.  Terminating."
  exit $EXIT_ERROR
}
trap '__term_exit' HUP INT QUIT TERM
# dash: EXIT (but no ERR)
__err_exit () {
  __echo 0 "Internal process returned an error exit.  Terminating."
  exit $EXIT_ERROR
}
__exit_exit () {
  # No error exit
  exit $EXIT_SUCCESS
}
trap '[ $? -eq 0 ] && __exit_exit || __err_exit' EXIT

##############################################################################
# @brief             convert $1 in seconds to day.hh:mm:ss string
# @arg   $1          seconds
# @echo              "day.hh:mm:ss" string
##############################################################################
age_string () {
  # @ $1 second
  SEC="$(($1))"
  MIN=$((SEC/60))
  SEC=$((SEC%60))
  HR=$((MIN/60))
  MIN=$((MIN%60))
  DAY=$((HR/24))
  HR=$((HR%24))
  printf "%2i.%02i:%02i:%02i" "$DAY" "$HR" "$MIN" "$SEC"
}

##############################################################################
# This is basically executed from this host
##############################################################################
# load parameters
##############################################################################
__load_config () {
  if [ -r "$BSS_CONF_BASE" ]; then
    __echo 3 "    configuration at    $BSS_CONF_BASE"
  else
    __echo 0 "    configuration missing, please use '$BSS template $FS_BASE'"
    exit $EXIT_ERROR
  fi
  if [ -r "$BSS_FLTR_BASE" ]; then
    __echo 3 "    filter        at    $BSS_FLTR_BASE"
  else
    __echo 3 "    filter  missing     (probably OK)."
  fi
  __echo 2 "Ensure to run a single instance of $BSS (wait up to 30 sec)" >&2
  # fd=9 not used elsewhere in this script. (/ home, ... starts this script)
  exec 9< "$0"
  if ! flock --wait 30 9 ; then
    __echo 0 "$BSS already running.  Try later" >&2
    exit 2
  fi
  __echo 2 "No other instance of $BSS found" >&2
  # make sure $BSS_DIR_BASE exists
  if [ ! -d "$BSS_DIR_BASE" ]; then
    if [ -z "$NOOP" ]; then
      $SUDO mkdir -p "$BSS_DIR_BASE" >/dev/null
      __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_DIR_BASE"
      # match owner with the parent directory
      $NOOP $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$BSS_DIR_BASE"
    else
      __echo 0 "$BSS is not configured yet but --noop or -n option was used."
      __echo 0 "  * Use '$BSS template' and edit generated template files first."
      __echo 0 ""
      __help
      exit $EXIT_ERROR
    fi
  fi
  if [ -r "$BSS_CONF_BASE" ]; then
    # shellcheck disable=SC1090
    . "$BSS_CONF_BASE"
    __echo 4 "Sourced $BSS_CONF for BASE=$FS_BASE"
  fi
  # normalize and sanity check parameters (ensure gaps TMIN TMID TMAX etc.)
  if [ "$BSS_NMIN" -lt "1" ]; then
    __echo 1 "Avoid awkward situation NMIN=$BSS_NMIN < 1, force NMIN=1"
    BSS_NMIN="1"
  fi
  if [ "$BSS_NMAX" -lt "0" ]; then
    __echo 1 "Avoid awkward situation NMAX=$BSS_NMAX < 0, force NMAX=0 (no_limit)"
    BSS_NMAX="0"
  fi
  BSS_TMIN=$(($BSS_TMIN))
  if [ "$BSS_TMIN" -lt "60" ]; then
    __echo 1 "Avoid awkward situation TMIN=$BSS_TMIN < 60, force TMIN=60"
    BSS_TMIN="60"
  fi
  BSS_TMID=$(($BSS_TMID))
  if [ "$BSS_TMID" -lt "$(($BSS_TMIN*2))" ]; then
    __echo 1 "Avoid awkward situation TMID=$BSS_TMID < TMIN*2=$BSS_TMIN*2, force TMID=$(($BSS_TMIN*2))"
    BSS_TMID="$(($BSS_TMIN*2))"
  fi
  BSS_TMAX=$(($BSS_TMAX))
  if [ "$BSS_TMAX" != "0" ] && [ "$BSS_TMAX" -lt "$BSS_TMID" ]; then
    __echo 1 "Avoid awkward situation TMAX=$BSS_TMAX < TMID*2=$BSS_TMID*2, force TMAX=$(($BSS_TMID*2))"
    BSS_TMAX="$(($BSS_TMID*2))"
  fi
  BSS_STEP=$(($BSS_STEP))
  if [ "$BSS_STEP" -lt "2" ]; then
    __echo 1 "Aging step too small, force STEP=2% (i.e. 1.02x age ratio from the younger one)"
    BSS_STEP=2
  elif [ "$BSS_STEP" -gt "90" ]; then
    __echo 1 "Aging step too big, force STEP=90% (i.e. 10x age ratio from the younger one)"
    BSS_STEP=90
  fi
  # normalize
  if [ "$BSS_TMAX_ACTION" = "drop" ] || [ "$BSS_TMAX_ACTION" = "DROP" ]; then
    BSS_TMAX_ACTION="drop"
  else
    BSS_TMAX_ACTION="keep"
  fi
  if [ "$BSS_TMID_ACTION" = "filter" ] || [ "$BSS_TMID_ACTION" = "FILTER" ]; then
    BSS_TMID_ACTION="filter"
  else
    BSS_TMID_ACTION="no_filter"
  fi
  if [ "$BSS_TMAX_ACTION" = "drop" ] && [ "$BSS_TMAX" = "0" ]; then
    __echo 1 "TMAX_ACTION is 'drop' despite TMAX=0 (no_limit), force to change TMAX_ACTION to 'keep'"
    BSS_TMAX_ACTION="keep"
  fi
  if [ "$BSS_TMID_ACTION" != "filter" ] && [ -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "TMID_ACTION=no_filter but unused filter $BSS_FLTR exists for BASE=$FS_BASE"
  fi
  if [ "$BSS_TMID_ACTION" = "filter" ] && [ ! -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "Force TMID_ACTION=no_filter since $BSS_FLTR is missing for BASE=$FS_BASE"
    BSS_TMID_ACTION="no_filter"
  fi
  # Human readable string
  S_NMIN="$BSS_NMIN"
  if [ "$BSS_NMAX" = "0" ]; then
    S_NMAX="no_limit"
  else
    S_NMAX="$BSS_NMAX"
  fi
  S_TMIN="$(age_string "$BSS_TMIN")"
  S_TMID="$(age_string "$BSS_TMID")"
  if [ "$BSS_TMAX" = "0" ]; then
    S_TMAX="no_limit"
  else
    S_TMAX="$(age_string "$BSS_TMAX")"
  fi
  if [ -z "$BSS_SNAP_DEST" ]; then
    # snapshot visible from the original FS
    BSS_SNAP_DEST_BASE="$BSS_DIR_BASE"
  else
    # snapshot non-visible from the original FS
    BSS_SNAP_DEST_BASE="$BSS_SNAP_DEST"
  fi
  __echo 3 "snapshot source: BASE=$FS_BASE"
  __echo 3 "snapshot destination: BSS_SNAP_DEST_BASE=$BSS_SNAP_DEST_BASE"
  __echo 3 "NMAX = '$BSS_NMAX' = $S_NMAX (maximum number of SV to keep)"
  __echo 3 "NMIN = '$BSS_NMIN' = $S_NMIN (minimum number of SV to keep)"
  __echo 3 "TMAX = '$BSS_TMAX' = $S_TMAX (time to stop aging)"
  __echo 3 "TMID = '$BSS_TMID' = $S_TMID (time to stop prioritizing and optionally apply filter)"
  __echo 3 "TMIN = '$BSS_TMIN' = $S_TMIN (time to start aging SV)"
  __echo 3 "STEP = '$BSS_STEP'% (age gap ratio to keep a newer SV, (age_gap_ratio) = (age_old - age_new)/age_old"
  __echo 3 "    STEP maximum     $(age_string $(($BSS_TMAX*$BSS_STEP/100)))"
  __echo 3 "    STEP middle      $(age_string $(($BSS_TMID*$BSS_STEP/100)))"
  __echo 3 "    STEP minimum     $(age_string $(($BSS_TMIN*$BSS_STEP/100)))"
  __echo 3 "TMAX_ACTION = '$BSS_TMAX_ACTION' (action at TMAX)"
  __echo 3 "TMID_ACTION = '$BSS_TMID_ACTION' (action at TMID)"
  __echo 3 "FMIN = '$BSS_FMIN'% (minimum required free disk % for snapshot)"
}

##############################################################################
__snapshot () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Snapshot not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # disk size sanity check without quota consideration
  BSS_STAT_TOTAL=$(stat -f -c %b "$FS_BASE")
  # Even on 4k block system, disk with 200 blocks is less than 1MB
  if [ "$BSS_STAT_TOTAL" -le 200 ]; then
    __echo 0 "Total disk size: $BSS_STAT_TOTAL blocks (too small, minimum required 200)"
    __echo 0 "Skip snapshot: BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    exit $EXIT_ERROR
  fi
  BSS_STAT_UNIT=$((BSS_STAT_TOTAL/100))
  BSS_STAT_FREE=$(stat -f -c %f "$FS_BASE")
  BSS_FREE_UNIT=$((BSS_STAT_FREE/BSS_STAT_UNIT))
  BSS_FMIN_PRE=$(($BSS_FMIN+20))
  if [ "$BSS_FREE_UNIT" -le "$BSS_FMIN" ]; then
    __echo 0 "Free disk space: $BSS_FREE_UNIT%  (too small, minimum required FMIN=$BSS_FMIN%)"
    __echo 0 "Skip snapshot: BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    exit $EXIT_ERROR
  elif [ "$BSS_FREE_UNIT" -lt "$BSS_FMIN_PRE" ]; then
    __echo 2 "Free disk space: $BSS_FREE_UNIT%  (enough, minimum required FMIN=$BSS_FMIN%)"
  else
    __echo 3 "Free disk space: $BSS_FREE_UNIT%  (enough, minimum required FMIN=$BSS_FMIN%)"
  fi
  # make snapshot (avoid the same time stamp)
  while [ -d "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}" ]; do
    sleep "1s"
    NOW_TSTR=$(date -u --iso=second)
  done
  if [ -z "$BSS_SNAP_DEST" ]; then
    __echo 2 "Make snapshot (user mode): BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    # normal mode
    # shellcheck disable=SC2086
    $NOOP $LOGGER $BSV snapshot -r "$FS_BASE" "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}"
  else
    __echo 2 "Make snapshot (system mode): BASE=$FS_BASE DEST=$BSS_SNAP_DEST_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    # system mode
    # shellcheck disable=SC2086
    $NOOP $LOGGER $BSV snapshot "$FS_BASE" "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}"
    if [ "$($BSV list -o "$FS_BASE" | wc -l)" != 0 ]; then
      __echo 1 "snapshot source contains nested subvolumes as follows.  Data in them are not in the snapshot taken."
      $LOGGER $BSV list -o "$FS_BASE"
    fi
  fi
}

##############################################################################
RE_ISO='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}[-+]00:00'
__list () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "List not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      .* (egrep pattern)
  # $2      "-r" for reverse, "" for normal
  # echo    snapshot time stamps
  __echo 4 "List snapshots for BASE=$FS_BASE matching TYPE_REGEX='${1}' (${2})"
  if [ -d "$BSS_SNAP_DEST_BASE" ]; then
    cd "$BSS_SNAP_DEST_BASE" >/dev/null
    # shellcheck disable=SC2086
    { ls -1d ${2} -- * 2>/dev/null || true ; }| \
      grep -E "^$RE_ISO\.${1}\$" || true
  else
    __echo 0 "No 'list' since snapshot directory $BSS_SNAP_DEST_BASE is missing for BASE=$FS_BASE"
    exit $EXIT_ERROR
  fi
}

##############################################################################
__age() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Age not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # echo    snapshot time stamps with + or - prepended
  __echo 4 "Assess aging status of snapshots for BASE=$FS_BASE"
  BSS_TLAST="-1" # Initial value place holder
  BSS_TSTEP=$((BSS_TMAX*BSS_STEP/100))
  # search in direction: old -> new
  BSS_LIST="$(__list '.*')"
  BSS_N="$(echo "$BSS_LIST" | wc -w)"
  # count down
  BSS_I="$BSS_N"
  for BSS_SV in $BSS_LIST ; do
    # Scan                     Scan from Old to New
    # Time   Old    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  New
    # Epoch  Small  --------------------------------------  Large
    # I             N-1 ................................ 0
    # LAST          BSS_TEPO(LAST)              NOW_TEPO   diff=TLAST
    # THIS             BSS_TEPO(THIS)           NOW_TEPO   diff=TAGE
    BSS_I=$((BSS_I-1))
    BSS_TSTR="${BSS_SV%%.*}"
    BSS_TYPE="${BSS_SV##*.}"
    BSS_EXTRA="${BSS_TYPE##*_}"
    if [ "$BSS_EXTRA" = "$BSS_TYPE" ]; then
      BSS_EXTRA=""
    fi
    BSS_TEPO=$(date '+%s' -d"$BSS_TSTR")
    BSS_TAGE=$((NOW_TEPO-BSS_TEPO))  # age of SV in seconds
    if [ "$BSS_TLAST" = "-1" ]; then
      # Ensure to keep the oldest SV
      BSS_TLAST="$(($BSS_TAGE+$BSS_TSTEP*2))"
    fi
    S_TAGE="$(age_string $BSS_TAGE)"
    # delta age of SV in seconds from last SV kept
    BSS_TDEL=$((BSS_TLAST-BSS_TAGE))
    S_TDEL="$(age_string $BSS_TDEL)"
    S_TSTEP="$(age_string $BSS_TSTEP)"
    #########################################################################
    # Index rules (no use to update TLAST, TDEL)
    #########################################################################
    #########################################################################
    # Keep
    # Classify: I < NMIN
    #########################################################################
    if [ "$BSS_I" -lt "$BSS_NMIN" ]; then
      __echo 2 "+++ TAGE=$S_TAGE, I=$BSS_I < NMIN=$S_NMIN, TYPE=$BSS_TYPE (keep: unconditional, before NMIN)"
      echo "+++_$BSS_SV"
    #########################################################################
    # Keep
    # Classify: TAGE < TMIN
    #########################################################################
    elif [ "$BSS_TAGE" -lt "$BSS_TMIN" ]; then
      __echo 2 "+++ TAGE=$S_TAGE < TMIN=$S_TMIN, TYPE=$BSS_TYPE (keep: unconditional, before TMIN)"
      echo "+++_$BSS_SV"
    #########################################################################
    # Keep
    # Classify: TYPE = keep
    #########################################################################
    elif [ "$BSS_TYPE" = "keep" ]; then
      __echo 2 "+++ TAGE=$S_TAGE, TYPE=$BSS_TYPE (keep: unconditional by TYPE)"
      if [ "$BSS_TAGE" -ge "$BSS_TMAX" ]; then
        BSS_TLAST="$BSS_TAGE"
      else
        BSS_TLAST="$BSS_TAGE"
        BSS_TSTEP=$((BSS_TLAST*BSS_STEP/100))
      fi
      echo "+++_$BSS_SV"
    #########################################################################
    # Drop
    # Classify: I > NMAX and NMAX > 0, i.e., except for no_limit
    #########################################################################
    elif [ "$BSS_I" -ge "$BSS_NMAX" ] && [ "$BSS_NMAX" -gt "0" ]; then
      __echo 2 "--- TAGE=$S_TAGE, $BSS_I >= NMAX=$S_NMAX, TYPE=$BSS_TYPE (drop: unconditional, after NMAX)"
      echo "---_$BSS_SV"
    #########################################################################
    # TMAX or older (keep step when keeping snapshot)
    #########################################################################
    #########################################################################
    # Drop action=drop
    # Classify: TAGE >= TMAX and TMAX_ACTION=drop (TMAX>0 pre checked)
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX_ACTION" = "drop" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMAX=$S_TMAX, TMAX_ACTION=$BSS_TMAX_ACTION, TYPE=$BSS_TYPE (drop: after TMAX)"
      echo "---_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMAX and TMAX>0 and TYPE = post
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TYPE" = "post" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMAX=$S_TMAX, TYPE=$BSS_TYPE (drop: special TYPE, after TMAX)"
      echo "---_$BSS_SV"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMAX=$S_TMAX, TDEL=$S_TDEL < TSTEP=$S_TSTEP, TYPE=$BSS_TYPE (drop: dense, after TMAX)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse as filtered
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL => TSTEP and TMID_ACTION=filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" = "filter" ]; then
      __echo 2 "### TAGE=$S_TAGE >= TMAX=$S_TMAX, TDEL=$S_TDEL >= TSTEP=$S_TSTEP, TMAX_ACTION=$BSS_TMAX_ACTION, TMID_ACTION=$BSS_TMID_ACTION, EXTRA=$BSS_EXTRA, TYPE=$BSS_TYPE (keep as filtered: sparse, keep step, after TMAX)"
      echo "###_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Keep sparse without filter
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL => TSTEP and TMID_ACTION != filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" != "filter" ]; then
      __echo 2 "+++ TAGE=$S_TAGE >= TMAX=$S_TMAX, TDEL=$S_TDEL => TSTEP=$S_TSTEP TMAX_ACTION=$BSS_TMAX_ACTION, TMID_ACTION=$BSS_TMID_ACTION, TYPE=$BSS_TYPE (keep: sparse, keep step, after TMAX)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMAX=$S_TMAX, TDEL=$S_TDEL < TSTEP=$S_TSTEP, TYPE=$BSS_TYPE (drop: dense, keep step, after TMAX)"
      echo "---_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # TMID or older (update step when keeping snapshot)
    #########################################################################
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMID and TYPE = post
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TYPE" = "post" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMID=$S_TMID, TYPE=$BSS_TYPE (drop: special TYPE, after TMID)"
      echo "---_$BSS_SV"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMID and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMID=$S_TMID, TDEL=$S_TDEL < TSTEP=$S_TSTEP, TYPE=$BSS_TYPE (drop: dense, after TMID)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse with filter
    # Classify: TAGE >= TMID and TDEL => TSTEP and TMID_ACTION=filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" = "filter" ]; then
      __echo 2 "### TAGE=$S_TAGE >= TMID=$S_TMID, TDEL=$S_TDEL >= TSTEP=$S_TSTEP, TMID_ACTION=$BSS_TMID_ACTION, EXTRA=$BSS_EXTRA, TYPE=$BSS_TYPE (keep as filtered: sparse, update step, after TMID)"
      echo "###_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST*BSS_STEP/100))
    #########################################################################
    # Keep sparse without filter
    # Classify: TAGE >= TMID and TDEL => TSTEP and TMID_ACTION != filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" != "filter" ]; then
      __echo 2 "+++ TAGE=$S_TAGE >= TMID=$S_TMID, TDEL=$S_TDEL => TSTEP=$S_TSTEP, TMID_ACTION=$BSS_TMID_ACTION, TYPE=$BSS_TYPE (keep: sparse, keep step, after TMID)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST*BSS_STEP/100))
    #########################################################################
    # TMIN or older
    #########################################################################
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMIN and TYPE = post
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TYPE" = "post" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMIN=$S_TMIN, TYPE=$BSS_TYPE (drop: special TYPE, after TMIN)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse
    # Classify: TAGE >= TMIN and TDEL > TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ]; then
      __echo 2 "+++ TAGE=$S_TAGE >= TMIN=$S_TMIN, TDEL=$S_TDEL >= TSTEP=$S_TSTEP, TYPE=$BSS_TYPE (keep: sparse, update step, after TMIN)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST*BSS_STEP/100))
    #########################################################################
    # Keep special TYPE
    # Classify: TAGE >= TMIN and TYPE = specials
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && { [ "$BSS_TYPE" = "pre" ] || [ "$BSS_TYPE" = "last" ] ; } ; then
      __echo 2 "+++ TAGE=$S_TAGE >= TMIN=$S_TMIN, TYPE=$BSS_TYPE (keep: special TYPE, update step, after TMIN)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST*BSS_STEP/100))
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMIN and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 2 "--- TAGE=$S_TAGE >= TMIN=$S_TMIN, TDEL=$S_TDEL < TSTEP=$S_TSTEP, TYPE=$BSS_TYPE (drop: dense, after TMIN)"
      echo "---_$BSS_SV"
    #########################################################################
    # NO WAY
    #########################################################################
    # Classify: ???
    #########################################################################
    else # This should never reached
      __echo 0 "??? TAGE=$S_TAGE, TDEL=$S_TDEL, I=$BSS_I, TYPE=$BSS_TYPE (XXX this should never be reached XXX)"
      exit $EXIT_SUCCESS
    fi
  done
}

##############################################################################
__process () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Process not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  __echo 2 "Process snapshots: BASE=$FS_BASE TIME=$NOW_TSTR"
  BASE_BSS_LOGGER_LEVEL="$BSS_LOGGER_LEVEL"
  if [ "$BSS_LOGGER_LEVEL" -le "3" ]; then
    __echo 2 "Assess aging status of snapshots internally: (silenced except for debug)"
    BSS_LOGGER_LEVEL="1" # Force __age to be quieter
  fi
  for XBSS_SV in $(__age); do
    BSS_LOGGER_LEVEL="$BASE_BSS_LOGGER_LEVEL"
    # drop first character + or - or #
    BSS_SV="${XBSS_SV#???_}"
    BSS_TSTR="${BSS_SV%%.*}"
    BSS_TYPE="${BSS_SV##*.}"
    BSS_EXTRA="${BSS_TYPE##*_}"
    if [ "$BSS_EXTRA" = "$BSS_TYPE" ]; then
      BSS_EXTRA=""
    fi
    BSS_TEPO=$(date '+%s' -d"$BSS_TSTR")
    BSS_TAGE=$((NOW_TEPO-BSS_TEPO))  # age of SV in seconds
    S_TAGE="$(age_string $BSS_TAGE)"
    if [ -z "${XBSS_SV%%---_*}" ]; then
      __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE"
      # shellcheck disable=SC2086
      $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    elif [ -z "${XBSS_SV%%+++_*}" ]; then
      __echo 3 "Keep snapshot: BASE=$FS_BASE SV=$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_EXTRA" != "filter" ]; then
      __echo 2 "Filter snapshot: BASE=$FS_BASE SV=$BSS_SV -> ${BSS_SV}_filter AGE=$S_TAGE"
      __filter "$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_FORCE" = "FORCE" ]; then
      __echo 2 "Filter snapshot again: BASE=$FS_BASE SV=$BSS_SV -> ${BSS_SV} AGE=$S_TAGE"
      __filter "$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_EXTRA" = "filter" ]; then
      __echo 3 "Keep snapshot (filtered): BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE"
    else
      __echo 1 "???? snapshot: BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE (XXX this should never be reached XXX)"
    fi
  done
}

##############################################################################
__jobs () {
  echo " $ systemctl --system list-timers 'bss-*'"
  systemctl --system list-timers 'bss-*'
  echo
  echo " $ systemctl --user list-timers 'bss-*'"
  systemctl --user list-timers 'bss-*'
}

##############################################################################
__filter () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Filter not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      SV to be filtered
  # Execution of filter $BSS_FLTR and snapshot operation are expected to be
  # heavy on CPU and SSD usage.
  BSS_SV="${1}"
  BSS_SV0="${BSS_SV%_filter}"
  # sanity check first
  if [ ! -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "Do nothing since $BSS_FLTR is missing for BASE=$FS_BASE"
    exit $EXIT_SUCCESS
  elif [ -d "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw" ]; then
    __echo 0 "Pre-existing ${BSS_SV0}_rw blocks filter BASE=$FS_BASE SV=$BSS_SV"
    exit $EXIT_ERROR
  elif [ "$BSS_FORCE" != "FORCE" ] && [ -d "$BSS_SNAP_DEST_BASE/${BSS_SV0}_filter" ]; then
    __echo 0 "Pre-existing ${BSS_SV0}_filter blocks filter BASE=$FS_BASE SV=$BSS_SV"
    exit $EXIT_ERROR
  else
    __echo 4 "Filter snapshot of BASE=$FS_BASE SV=$BSS_SV with $BSS_FLTR"
    # shellcheck disable=SC2086
    $NOOP $LOGGER $BSV snapshot "$BSS_SNAP_DEST_BASE/$BSS_SV/" "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw"
    # filter snapshot subvolume contents
    # shellcheck disable=SC2086
    { $NOOP cd "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw" >/dev/null ; $NOOP $LOGGER $SUDO sh < "$BSS_FLTR_BASE" ; }
    # remove the original snapshot now for --force
    if [ "$BSS_SV" != "$BSS_SV0" ]; then
      # subvolume already filtered
      if [ "$BSS_FORCE" = "FORCE" ]; then
        # shellcheck disable=SC2086
        $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      else
        __echo 0 "Use '--force' to filter BASE=$FS_BASE SV=$BSS_SV"
        exit $EXIT_ERROR
      fi
    fi
    # shellcheck disable=SC2086
    $NOOP $LOGGER $BSV snapshot -r "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw" "$BSS_SNAP_DEST_BASE/${BSS_SV0}_filter"
    # shellcheck disable=SC2086
    $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw"
    # remove the original snapshot at last to be safe for normal TYPE without tailing _filter
    if [ "$BSS_SV" = "$BSS_SV0" ]; then
      # shellcheck disable=SC2086
      $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    fi
  fi
}

##############################################################################
__revert () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Revert not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      revert to this SV
  BSS_SV="${1}"
  # sanity check
  if [ "$FS_BASE" = "/" ]; then
    __echo 0 "No revert allowed: BASE=$FS_BASE, reboot from a different root filesystem."
    exit $EXIT_ERROR
  fi
  if [ -z "$BSS_SNAP_DEST" ]; then
    __echo 0 "No revert supported: BSS_SNAP_DEST_BASE must be defined as non-null string in $BSS_CONF."
    exit $EXIT_ERROR
  fi
  # make last snapshot
  BSS_TYPE="last"
  __snapshot
  __echo 0 "revert $FS_BASE with $BSS_SNAP_DEST_BASE/$BSS_SV"
  $NOOP $LOGGER $BSV delete "$FS_BASE"
  $NOOP $LOGGER $BSV snapshot "$BSS_SNAP_DEST_BASE/$BSS_SV" "$FS_BASE"
}

##############################################################################
__zap () {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Zap not available: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  if [ "$BSS_ZAP_ACTIVE" != "true" ]; then
      __echo 0 "No zap operation since $BSS_CONF at BASE=$FS_BASE has BSS_ZAP_ACTIVE='$BSS_ZAP_ACTIVE'"
      exit $EXIT_ERROR
  fi
  __echo 4 "Zap snapshots: BASE=$FS_BASE"
  case "$1" in
    half) # half
      __echo 2 "Zap snapshots into half: BASE=$FS_BASE"
      # search in reverse direction: old -> new
      BSS_LIST="$(__list '.*' -r)"
      BSS_N="$(echo "$BSS_LIST" | wc -w)"
      # count down
      BSS_I="$BSS_N"
      BSS_NH="$(((BSS_N)/2))"
      if [ "$BSS_NH" -lt "$BSS_NMIN" ]; then
        BSS_NH="$BSS_NMIN"
      fi
      for BSS_SV in $BSS_LIST ; do
        BSS_I=$((BSS_I-1))
        if [ "$BSS_I" -gt "$BSS_NH" ]; then
          __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV"
          # shellcheck disable=SC2086
          $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
        else
          __echo 3 "Keep snapshot: BASE=$FS_BASE SV=$BSS_SV"
        fi
      done
      ;;
    new*) # newest
      BSS_SV="$(__list '.*' '-r' | head -n 1)"
      __echo 2 "Del. newest snapshot: BASE=$FS_BASE SV=$BSS_SV"
      # shellcheck disable=SC2086
      $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      ;;
    old*) # oldest
      BSS_SV="$(__list '.*' | head -n 1)"
      __echo 2 "Del. oldest snapshot: BASE=$FS_BASE SV=$BSS_SV"
      # shellcheck disable=SC2086
      $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      ;;
    *) # labels (local only now)
      __echo 3 "Del. listed snapshots: BASE=$FS_BASE"
      for BSS_SV in "${@}"; do
        if [ -e "$BSS_SNAP_DEST_BASE/$BSS_SV" ]; then
          __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV"
          # shellcheck disable=SC2086
          $NOOP $LOGGER $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
        else
          __echo 1 "Missing snapshot to zap: BASE=$FS_BASE SV=$BSS_SV"
        fi
      done
      ;;
  esac
}

##############################################################################
__rsync () {
  # override destination
  if [ -n "$1" ]; then
    BSS_COPY_DEST="$1"
    shift
  fi
  # process aliases
  case $BSS_COPY_DEST in
    1) BSS_COPY_DEST="$BSS_COPY_DEST1"
      ;;
    2) BSS_COPY_DEST="$BSS_COPY_DEST2"
      ;;
    3) BSS_COPY_DEST="$BSS_COPY_DEST3"
      ;;
  esac
  # remove tailing /
  while [ "$BSS_COPY_DEST" = "${BSS_COPY_DEST%/}/" ]; do
    BSS_COPY_DEST="${BSS_COPY_DEST%/}"
  done
  # sanity checks
  if [ -z "$BSS_COPY_DEST" ]; then
    __echo 0 "No copy destination given (or was /)"
    exit $EXIT_ERROR
  fi
  if [ -x "$BSS_SNAP_DEST_BASE/$BSS_COPY_PRE" ]; then
    __echo 2 "Run $BSS_COPY_PRE before copy"
    # shellcheck disable=SC1090
    . "$BSS_SNAP_DEST_BASE/$BSS_COPY_PRE"
  fi
  # relaxed rule to allow missing tailing /
  if [ "$FS_TYPE" = "btrfs" ]; then
    __echo 2 "Make copy: BASE=$FS_BASE TIME=${NOW_TSTR} DEST=$BSS_COPY_DEST/"
    if [ "${BSS_COPY_DEST}" != "${BSS_COPY_DEST#/}" ]; then
      # absolute local path
      RSYNC_OPTS="$RSYNC_OPTA"
    else
      RSYNC_OPTS="$RSYNC_OPTR"
    fi
    # --filter to exclude $BSS directory
    # Hidden undocumented argument handling: $@ (after source)
    # shellcheck disable=SC2086
    $NOOP $LOGGER $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
        "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}/" \
        "$BSS_COPY_DEST/"
    # Since this could be slow long process, record ending
    __echo 2 "... Successfully made copy: BASE=$FS_BASE TIME=${NOW_TSTR} DEST=$BSS_COPY_DEST/"
  elif [ "$FS_TYPE" = "ext2/ext3" ]; then
    __echo 2 "Make copy: BASE=$FS_BASE DEST=$BSS_COPY_DEST/"
    if [ "${BSS_COPY_DEST}" != "${BSS_COPY_DEST#/}" ]; then
      # absolute local path
      RSYNC_OPTS="$RSYNC_OPTA"
    else
      RSYNC_OPTS="$RSYNC_OPTR"
    fi
    # --filter to exclude $BSS directory
    # Hidden undocumented argument handling: $@ (after source)
    # shellcheck disable=SC2086
    $NOOP $LOGGER $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
        "$FS_BASE/" \
        "$BSS_COPY_DEST/"
    # Since this could be slow long process, record ending
    __echo 2 "... Successfully made copy: BASE=$FS_BASE DEST=$BSS_COPY_DEST/"
  else
    __echo 0 "copy for unknown FS=$FS_TYPE requested."
    exit $EXIT_ERROR
  fi
  if [ -x "$BSS_SNAP_DEST_BASE/$BSS_COPY_POST" ]; then
    __echo 2 "Run $BSS_COPY_POST after copy"
    # shellcheck disable=SC1090
    . "$BSS_SNAP_DEST_BASE/$BSS_COPY_POST"
  fi
}
##############################################################################
__template () {
  # make sure $BSS_DIR_BASE exists
  if [ ! -d "$BSS_DIR_BASE" ]; then
    if [ -z "$NOOP" ]; then
      $SUDO mkdir -p "$BSS_DIR_BASE" >/dev/null
      # match owner with the parent directory
      $NOOP $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$BSS_DIR_BASE"
    else
      __echo 0 "'$BSS template' must not be used with --noop nor -n option."
      exit $EXIT_ERROR
    fi
  fi
  ############################################################################
  #
  # conf and filter template
  #
  ############################################################################
  #
  ### CONFIGURATION ###
  #
  if [ -e "$BSS_CONF_BASE" ]; then
    __echo 1 "Configuration file already exists: $BSS_CONF for BASE=$FS_BASE, keep it as is."
    __echo 2 "Loading existing $BSS_CONF for BASE=$FS_BASE."
    __load_config
  else
    if [ "$FS_BASE" = "/" ]; then
      BSS_TMID_ACTION="filter"
      __echo 2 "Suggest BSS_TMID_ACTION=\"filter\" in template since BASE=$FS_BASE (full system)"
    else
      BSS_TMID_ACTION="no_filter"
    fi
    __echo 2 "Make configuration $BSS_CONF_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
    $SUDO tee "$BSS_CONF_BASE" >/dev/null << END_OF_TEMPLATE
# $BSS configuration (btrfs)

# This configuration file as generated by the "template" command.
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#

### Active DATA AGING PARAMETERS
BSS_NMIN="$BSS_NMIN"  # NMIN: minimum items to keep (initial)
BSS_NMAX="$BSS_NMAX"  # NMAX: maximum items to keep (last, if 0, keep all)
BSS_TMAX="$BSS_TMAX"  # TMAX: stop aging, $(age_string $BSS_TMAX)
BSS_TMID="$BSS_TMID"  # TMID: start process, $(age_string $BSS_TMID)
BSS_TMIN="$BSS_TMIN"  # TMIN: start aging, $(age_string $BSS_TMIN)
BSS_STEP="$BSS_STEP"  # STEP: aging step $BSS_STEP %, $(age_string $(($BSS_TMAX*$BSS_STEP/100))) at BSS_TMAX
BSS_TMAX_ACTION="$BSS_TMAX_ACTION"  # TMAX_ACTION: action at TMAX.  'keep' or 'drop'
BSS_TMID_ACTION="$BSS_TMID_ACTION"  # TMID_ACTION: action at TMID.  'filter' or 'no_filter'
BSS_FMIN="$BSS_FMIN"  # FMIN: minimum required free disk % for snapshot

### Baseline DATA AGING PARAMETERS
## BSS_NMIN="$BSS_NMIN"  # NMIN: minimum items to keep (initial)
## BSS_NMAX="$BSS_NMAX"  # NMAX: maximum items to keep (last, if 0, keep all)
## BSS_TMAX="$BSS_TMAX"  # TMAX: stop aging, $(age_string $BSS_TMAX)
## BSS_TMID="$BSS_TMID"  # TMID: start process, $(age_string $BSS_TMID)
## BSS_TMIN="$BSS_TMIN"  # TMIN: start aging, $(age_string $BSS_TMIN)
## BSS_STEP="$BSS_STEP"  # STEP: aging step $BSS_STEP %, $(age_string $(($BSS_TMAX*$BSS_STEP/100))) at BSS_TMAX
## BSS_TMAX_ACTION="$BSS_TMAX_ACTION"  # TMAX_ACTION: action at TMAX.  'keep' or 'drop'
## BSS_TMID_ACTION="$BSS_TMID_ACTION"  # TMID_ACTION: action at TMID.  'filter' or 'no_filter'
## BSS_FMIN="$BSS_FMIN"  # FMIN: minimum required free disk % for snapshot

## Following parameters defines the aging behavior.
##
## * BSS_NMAX:
##   maximum number of snapshots to keep If this is set to 0, no limit on number
##   of snapshots
## * BSS_NMIN:
##   number of initial snapshots to keep unconditionally
## * BSS_STEP:
##   This parameter defines the rule to drop snapshots for aging.  If the age of a
##   snapshot is BSS_STEP % less than the age of the last kept snapshot, such a
##   snapshot is dropped.
## * BSS_TMAX:
##   If the age of a snapshot is older than BSS_TMAX, aging rule based on BSS_STEP
##   is disabled.  BSS_TMAX=0 means no age check for TMAX (no_limit).
## * BSS_TMID:
##   If the age of a snapshot is older than BSS_TMID, snapshots with type 'post' are
##   dropped and other snapshots are aged using BSS_STEP.  If filter is active,
##   snapshots are filtered.
## * BSS_TMIN:
##   If the age of a snapshot is older than BSS_TMIN, snapshots with type 'post' are
##   dropped, snapshots with type 'single' and 'hour' are aged using BSS_STEP,
##   snapshots with type 'boot', and 'pre' are kept unconditionally.
## * BSS_TMAX_ACTION:
##   Determine the action at TMAX.  Default is 'keep'.  Set this to 'drop' to
##   remove snapshots at TMAX.
## * BSS_TMID_ACTION:
##   Determine the action at TMID.  Default for the normal data filesystem is
##   'no_filter'.  Set this to 'filter' to activate filter to reduce remote backup
##   size.
## * BSS_FMIN:
##   If the number of free disk blocks is smaller than BSS_FMIN % of the total
##   number of disk blocks, the snapshot operation will fail to avoid filling
##   up the disk.

### EXTRA PARAMETERS ###

# safety (change this if you want to disable some zap operations)
BSS_ZAP_ACTIVE="true"

# convenience for "$BSS copy".  Set this to non-zero string to activate default destination.
BSS_COPY_DEST=""
# convenience for "$BSS copy".  Use this when destination is "1" ("1" works as alias).
BSS_COPY_DEST1=""
# convenience for "$BSS copy".  Use this when destination is "2" ("2" works as alias).
BSS_COPY_DEST2=""
# convenience for "$BSS copy".  Use this when destination is "3" ("3" works as alias).
BSS_COPY_DEST3=""

# enhancement for "$BSS snapshot".  Set this to non-zero string "<offset_path>"
# pointing to an absolute path to activate the non-default destination for the
# btrfs snapshot accessible only from outside of the original filesystem.
BSS_SNAP_DEST=""

### NOTE ###

# You can add a custom script to filter contents at TMID as $BSS_FLTR in this directory
# You can add a custom script to run before copy as $BSS_COPY_PRE in this directory
# You can add a custom script to run after copy as $BSS_COPY_PRE in this directory

# Many internal variables are prefixed with 'BSS_' to be unique to "$BSS" but
# the dialog messages may just use the rest of variable name to be concise.
END_OF_TEMPLATE
    __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_CONF_BASE and $BSS_FLTR_BASE"
  # shellcheck disable=SC2086
    $NOOP $SUDO chown $FS_BASE_UID:$FS_BASE_GID "$BSS_CONF_BASE"
  fi
  #
  ### FILTER ###
  #
  if [ -e "$BSS_FLTR_BASE" ] ; then
    __echo 1 "Filter file already exists: $BSS_FLTR for BASE=$FS_BASE, keep it as is."
  else
    __echo 2 "Creating template: $BSS_FLTR for BASE=$FS_BASE."
    if [ "$FS_BASE" = "/" ]; then
      __echo 2 "Make filter $BSS_FLTR_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
      $SUDO tee "$BSS_FLTR_BASE" >/dev/null << END_OF_TEMPLATE
# $BSS filter (better to use relative path)
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#
# Running filter drains CPU and SSD resources but it may save SSD usage size
# significantly.  If you are not interested in reducing SSD usage size by this
# script, remove this file and set BSS_TMID_ACTION="no_filter" in "$BSS_CONF"
#
# This is intended as template file.  As provided, this removes many
# non-administrator generated files to reduce disk usage size significantly.
# Edit this to your taste and set BSS_TMID_ACTION="filter" in "$BSS_CONF" to
# use this filter.  Otherwise remove this file and set
# BSS_TMID_ACTION="no_filter" in "$BSS_CONF".
#
### Remove all files under /tmp
rm -rf tmp var/tmp

### Remove most files under /var
rm -rf var/cache var/log var/spool var/lib/apt

### Remove /usr excluding /usr/local
find usr -maxdepth 1 -mindepth 1 -type d ! -name local -exec rm -rf '{}' +

### Remove very old kernel and initrd in /boot
find boot -type f -name 'initrd*' -exec rm -rf '{}' \;
find boot -type f -name 'vmlinu*' -exec rm -rf '{}' \;

END_OF_TEMPLATE
    else
      __echo 2 "Make filter $BSS_FLTR_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
      $SUDO tee "$BSS_FLTR_BASE" >/dev/null << END_OF_TEMPLATE
# $BSS filter (better to use relative path)
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#
# Running filter drains CPU and SSD resources but it may save SSD usage size
# significantly.  If you are not interested in reducing SSD usage size by this
# script, remove this file and set BSS_TMID_ACTION="no_filter" in "$BSS_CONF"
#
# This is intended as template file.  As provided, this is nothing but resource
# drain.  Edit this to your taste and set BSS_TMID_ACTION="filter" in
# "$BSS_CONF" to use this filter.  Otherwise remove this file and set
# BSS_TMID_ACTION="no_filter" in "$BSS_CONF".
#
###### Example for <user> subvolume at FS_BASE=/home/<user>

### Trace filter execution
#set -x

### Remove all files under .cache
#rm -rf .cache

### Remove huge (>20 MB) files (mostly iso, tar.gz, ...)
#find . -type f -size +20M ! -iname '*.mov' -delete

### Remove core files
#find . -type f -name core -delete

### Remove old .git/ directory contents ('-depth' is needed to avoid error message)
#find . -depth -type d -name '.git' -exec rm -rf '{}' \;

END_OF_TEMPLATE
    fi
    __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_CONF_BASE and $BSS_FLTR_BASE"
  # shellcheck disable=SC2086
    $NOOP $SUDO chown $FS_BASE_UID:$FS_BASE_GID "$BSS_FLTR_BASE"
  fi
  if [ "$BSS_TMID_ACTION" != "filter" ]; then
    __echo 2 "Please reconcile settings."
    __echo 2 " * Update $BSS_CONF to set MID_ACTION='filter' to use properly updated $BSS_FLTR."
    __echo 2 " * Keep $BSS_CONF to set MID_ACTION='no_filter' and remove template $BSS_FLTR."
  fi
}


##############################################################################
# Parse Command Line
##############################################################################
# The quotes around "$@" are essential!
# We need TEMP as the 'eval set --' would nuke the return value of getopt.
TEMP=$(getopt -o 't:c:s:fnqvxhl' -n "${BSS}" \
  --long 'type:,config:,snap:,force,noop,quiet,version,verbose,trace,help,logger' -- "$@")
# Note the quotes around "$TEMP": they are essential!
#echo "DEBUG: ***** TEMP='$TEMP'"
eval set -- "$TEMP"
unset TEMP
# OPTIONS
while [ -n "$1" ]; do
  case "$1" in
    -t|--type)
      shift
      BSS_TYPE="$1"
      ;;
    -c|--config)
      shift
      BSS_STEM="$1"
      ;;
    -f|--force)
      BSS_FORCE="FORCE"
      ;;
    -n|--noop)
      NOOP="echo __" # ANY non ""
      ;;
    -q|--quiet)
      BSS_LOGGER_LEVEL=1
      ;;
    --version)
      __version
      exit $EXIT_SUCCESS
      ;;
    -v|--verbose)
      BSS_LOGGER_LEVEL=$((BSS_LOGGER_LEVEL+1))
      ;;
    -x|--trace)
      SETX_ON="set -x"
      SETX_OFF="set +x"
      ;;
    -h|--help)
      __help
      exit $EXIT_SUCCESS
      ;;
    -l|--logger)
      BSS_LOGGER=1
      ;;
    '--')
      shift
      break
    ;;
    -*)
      echo "E: Unknown option: '$1'" >&2
      __help
      exit $EXIT_ERROR
    ;;
    *)
      break
    ;;
  esac
  shift
done
# derivative parameters
BSS_CONF="$BSS_STEM.$EXT_CONF"
BSS_FLTR="$BSS_STEM.$EXT_FLTR"
$SETX_ON
if [ "$BSS_LOGGER" = "1" ]; then
  case $BSS_MSG_LEVEL in
    0) LOGGER="systemd-cat -p 3 -t bss"
      ;;
    1) LOGGER="systemd-cat -p 4 -t bss"
      ;;
    2) LOGGER="systemd-cat -p 5 -t bss"
      ;;
    3) LOGGER="systemd-cat -p 6 -t bss"
      ;;
    4|5|6|7) LOGGER="systemd-cat -p 7 -t bss"
      ;;
  esac
else
  LOGGER=""
fi
##############################################################################
# find the BASE path of btrfs: FS_BASE
##############################################################################
if [ -z "$1" ]; then
  BSS_COMMAND="snapshot"
  # FS_BASE0: current path
  FS_BASE0=$($SUDO realpath ".")
else
  BSS_COMMAND="$1"
  shift
  if [ -z "$1" ]; then
    FS_BASE0=$($SUDO realpath ".")
  else
    FS_BASE0=$($SUDO realpath "${1}")
    shift
  fi
fi
# sanity check
FS="$($SUDO stat -f -c %T "$FS_BASE0")"
if [ "$FS" != "btrfs" ]; then
  __echo 0 "$BSS exits normally since source is on $FS and not on btrfs: $FS_BASE0 for TYPE=$BSS_TYPE"
  exit $EXIT_ERROR
fi
FS_BASE="$FS_BASE0"
if [ "$($SUDO stat -f -c %T "$FS_BASE")" = "btrfs" ]; then
  FS_TYPE="btrfs"
  while true; do
    # A subvolume has always inode number 256
    if [ "$($SUDO stat -c %i "$FS_BASE")" = "256" ]; then
      break
    fi
    # sanity check
    if [ "$($SUDO stat -f -c %T "$FS_BASE")" != "btrfs" ] || \
       [ "$FS_BASE" = "/" ]; then
      __echo 0 "No inode=256 on btrfs found from: $FS_BASE0"
      exit $EXIT_ERROR
    fi
    FS_BASE=$($SUDO realpath "$FS_BASE/..")
    __echo 4 "Check btrfs: BASE=$FS_BASE inode=$($SUDO stat -c %i "$FS_BASE")"
  done
elif [ "$($SUDO stat -f -c %T "$FS_BASE")" = "ext2/ext3" ]; then
  FS_TYPE="ext2/ext3"
  while true; do
    # root inode number 2 for ext2/ext3
    if [ "$($SUDO stat -c %i "$FS_BASE")" = "2" ]; then
      break
    fi
    # sanity check
    if [ "$($SUDO stat -f -c %T "$FS_BASE")" != "ext2/ext3" ] || \
       [ "$FS_BASE" = "/" ]; then
      __echo 0 "No inode=2 on ext2/ext3 found from: $FS_BASE0"
      exit $EXIT_ERROR
    fi
    FS_BASE=$($SUDO realpath "$FS_BASE/..")
    __echo 4 "Check ext2/ext3: BASE=$FS_BASE inode=$($SUDO stat -c %i "$FS_BASE")"
  done
else
  FS_TYPE="$($SUDO stat -f -c %T "$FS_BASE")"
  __echo 0 "Unsupported file system $FS_TYPE found at: $FS_BASE0"
  exit $EXIT_ERROR
fi
# FS_BASE: root of btrfs subvolume
FS_BASE_UID=$($SUDO stat -c %u "$FS_BASE")
FS_BASE_GID=$($SUDO stat -c %g "$FS_BASE")
BSS_DIR_BASE="${FS_BASE%/}/$BSS_DIR"
BSS_CONF_BASE="$BSS_DIR_BASE/$BSS_CONF"
BSS_FLTR_BASE="$BSS_DIR_BASE/$BSS_FLTR"

##############################################################################
__echo 4 "NOOP             = '$NOOP'"
__echo 4 "BSS_CONF         = '$BSS_CONF'"
__echo 4 "BSS_FLTR         = '$BSS_FLTR'"
__echo 4 "BSS_TYPE         = '$BSS_TYPE'"
__echo 4 "BSS_LOGGER       = '$BSS_LOGGER'"
__echo 4 "BSS_LOGGER_LEVEL = '$BSS_LOGGER_LEVEL'"
__echo 3 "Run '$BSS $BSS_COMMAND'       on BASE=$FS_BASE (inode=256) $FS_BASE_UID:$FS_BASE_GID"
#############################################################################
case "$BSS_COMMAND" in
  s*) #snapshot
    __load_config
    __snapshot
    ;;
  l*) # list
    __load_config
    if [ -z "$1" ]; then
      __list '.*'
    else
      __list "$1" "$2"
    fi
    ;;
  a*) # assess aging status
    __load_config
    __age
    ;;
  o*) # overview
    __load_config
    if [ "$BSS_LOGGER_LEVEL" -le "2" ]; then
      BSS_LOGGER_LEVEL="$(($BSS_LOGGER_LEVEL+1))"
      __age>/dev/null
    else
      __age
    fi
    ;;
  j*) # jobs
    __jobs
    ;;
  b*) # base
    echo "$FS_BASE"
    __load_config
    ;;
  p*) # process
    __load_config
    __process
    ;;
  f*) # filter
    __load_config
    __filter "$1"
    ;;
  r*) # revert
    __load_config
    __revert "$1"
    ;;
  zap) # zap
    __load_config
    __zap "$@"
    ;;
  t*) # template
    __template
    ;;
  c*) # copy
    __load_config
    if [ "$FS_TYPE" = "btrfs" ]; then
      if [ "$BSS_TYPE" = "single" ]; then
        BSS_TYPE='copy'
      fi
      __snapshot
    fi
    __rsync "$@"
    ;;
  h*|'') # help
    __help
    ;;
  *) # unknown
    __echo 0 "Unknown command: '$*'"
    __help
    exit $EXIT_ERROR
    ;;
esac
# Normal case
exit $EXIT_SUCCESS
