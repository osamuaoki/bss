#!/bin/sh -e
# vim:se sw=2 ts=2 sts=2 et ai tw=78:
#
# This script creates a filesystem image file in which LUKS encrypted data is
# stored.  This is aimed to store sensitive data securely with remote host
# service rsync.net using rsync.  For other cloud services, rsync may need to
# be replaced with rclone command.
#
# See /usr/share/doc/bss/examples/README.md
#
### VARIABLES ###
HOME="$(eval echo ~)"
SECRETFOLDER="${0##*/}"
# device mapper target name
DEVMAPPER_TARGET="${DEVMAPPER_TARGET:-secret}"
# rsync target path name
RSYNC_TARGET="${RSYNC_TARGET:-rsync}"
# device mapper path
PATH_DEVMAPPER="/dev/mapper/$DEVMAPPER_TARGET"
# disk image path
PATH_DISK="$HOME/$RSYNC_TARGET/$DEVMAPPER_TARGET.img"
# mount path
PATH_MNT="$HOME/$DEVMAPPER_TARGET"
# config path
PATH_CONF="$HOME/.${DEVMAPPER_TARGET}rc"
# set mode
ECHO="echo"
TSLEEP="0"
NEW="0"
MOUNT="0"
UPDATE="0"
KEEP="0"
ASK="0"
SIZE_DISK="16G"

### FUNCTIONS ###
new_secret () {
  if ! secret-tool lookup LUKS "$PATH_DISK" >/dev/null ; then
    echo "I: Setup passphrase for LUKS: $PATH_DISK" >&2
    secret-tool store --label="LUKS $PATH_DISK" LUKS "$PATH_DISK"
  else
    echo "I: Passphrase for LUKS aleady stored: $PATH_DISK" >&2
  fi
  echo "I: create $SIZE_DISK image: $PATH_DISK" >&2
  fallocate -l "$SIZE_DISK" "$PATH_DISK"
  echo "I: create LUKS in $PATH_DISK" >&2
  secret-tool lookup LUKS "$PATH_DISK" | \
    cryptsetup luksFormat "$PATH_DISK" -
  echo "I: open LUKS as $PATH_DEVMAPPER" >&2
  secret-tool lookup LUKS "$PATH_DISK" | \
    sudo cryptsetup open "$PATH_DISK" "$DEVMAPPER_TARGET" --type luks
  echo "I: create btrfs in $PATH_DEVMAPPER" >&2
  sudo mkfs.ext4 "$PATH_DEVMAPPER"
  echo "I: mount $PATH_DEVMAPPER on $PATH_MNT"
  sudo mount "$PATH_DEVMAPPER" "$PATH_MNT"
  echo "I: set $PATH_MNT to UID:GID=1000:1000" >&2
  sudo chown "1000:1000" "$PATH_MNT"
  {
    echo "!!! Don't write into ~/secret/ manually           !!!"
    echo "!!! This should be accessed only by secret-folder !!!"
  } > "$PATH_MNT/DO_NOT_WRITE_IN_MANUALLY"
}

check_secret () {
  if [ ! -e "$PATH_DISK" ]; then
    $ECHO "E: disk image missing: $PATH_DISK"
    $ECHO "I: create disk image interactively as: ${0##*/} new [size]"
    exit 1
  fi
  # wait for 120s if run by systemd start up, otherwise no wait
  sleep $TSLEEP
}

mount_secret () {
  # let's mount
  if mount|grep -e "$PATH_MNT" >/dev/null; then
    $ECHO "I: skip mounting:   $PATH_DEVMAPPER on $PATH_MNT"
    $ECHO "I: already mounted: $(mount|grep -e "$PATH_MNT"|sed 's/type.*$//')"
  else
    $ECHO "I: unlock LUKS disk image $PATH_DISK as $PATH_DEVMAPPER"
    if [ "$ASK" = "1" ]; then
      sudo cryptsetup open "$PATH_DISK" "$DEVMAPPER_TARGET" --type luks
    else
      secret-tool lookup LUKS "$PATH_DISK" | \
        sudo cryptsetup open "$PATH_DISK" "$DEVMAPPER_TARGET" --type luks
    fi
    $ECHO "I: mount $PATH_DEVMAPPER on $PATH_MNT"
    sudo mount "$PATH_DEVMAPPER" "$PATH_MNT"
  fi
  $ECHO "I: disk image usage (size used avail use%): $(df -h "$PATH_MNT" \
    | grep "$PATH_MNT" \
    | sed -e 's/\s\s*/ /g' \
    | cut -d' ' -f 2-5)"
}

backup_secret () {
$ECHO "I: back up to $PATH_MNT"
while read -r F ; do
  D="$(dirname "$F")"
  if [ "$D" = "." ]; then
    D=""
  else
    D="$D/"
  fi
  if [ -f "$F" ]; then
    if [ -n "$D" ]; then
      mkdir -p "$PATH_MNT/$D"
    fi
    rsync -a "$HOME/$F" "$PATH_MNT/$D"
  elif [ -d "$F" ]; then
    mkdir -p "$PATH_MNT/$F"
    rsync -ax --del "$HOME/$F/" "$PATH_MNT/$F"
  else
    $ECHO "broken ${0##*/}: $F non-existing"
  fi
done
}

unmount_secret () {
  sync;sync;sync
  sudo umount "$PATH_MNT" || true
  sudo cryptsetup close "$DEVMAPPER_TARGET" || true
}

help () {
cat << END_OF_HELP
Usage: ${SECRETFOLDER} [new [size]|mount|keep|update|systemd|ask]

"$SECRETFOLDER" helps to create and update encrypted disk image.

COMMAND:

  * new [size]: make a new disk image of specified size.
                Optional size can be specified as '32G'.
  * mount:      mount disk image ~/rsync/secret.img to ~/secret
  * keep:       don't unmount when exiting secret-folder
                (default behavior is unmount on exit)
  * update:     mount disk image and update its content by copying files and
                directories listed in ~/.secretrc.
  * systemd:    run from systemd timer unit in background while recording log to
                journald.
  * ask:        ask passphrase to unlock LUKS encryption
                (unless this is set, GNOME secret-tool is used to obtain
                passphrase)

These commands may be shortened to a single character.

See /usr/share/doc/bss/examples/README.md or
    https://github.com/osamuaoki/bss/tree/main/examples

Copyright 2022 Osamu Aoki <osamu@debian.org>, GPL 2+
END_OF_HELP
}

### MAIN ###

cd "$HOME"
mkdir -p "$PATH_MNT"

if [ ! -e "$PATH_CONF" ]; then
  cat >"$PATH_CONF" <<EOF
# Edit this to adopt to the system
####################################
# Files to backup
.bash_logout
.bashrc
.profile
.bash_aliases
#.bash_fzf_completion
#.bash_fzf_keybindings
.bashrc
.benrc
#.caffrc
#.debrc
.devscripts
.gbp.conf
.gitconfig
#.quiltrc-dpkg
.reportbugrc
.sbuildrc
#.shellcheckrc
#.config/black
#.config/flake8
#.config/pylintrc
####################################
# directories to backup
Documents
bin
.ssh
.gnupg
.config/autostart
.config/systemd/user
.local/share/keyrings
EOF
fi

while [ -n "$1" ]; do
  case "$1" in
    n*) # new
      shift
      if [ "$ECHO" != "echo" ]; then
        echo "E: 'new' can't be set under 'systemd'"
        exit 1
      fi
      if [ -n "$1" ];then
        SIZE_DISK="$1"
        shift
      fi
      NEW="1"
      # overrides
      MOUNT="0"
      ECHO="echo"
      break
      ;;
    s*) # systemd
      shift
      ECHO="systemd-cat -p 5 -t bss echo"
      TSLEEP="120"
      ASK="0"
      ;;
    m*) # mount
      shift
      MOUNT="1"
      ;;
    u*) # update
      shift
      MOUNT="1"
      UPDATE="1"
      ;;
    k*) # keep
      shift
      MOUNT="1"
      KEEP="1"
      ;;
    a*) # ask
      shift
      if [ "$ECHO" != "echo" ]; then
        echo "E: 'ask' can't be set under 'systemd'"
        exit 1
      fi
      ASK="1"
      ;;
    *)
      help
      exit 0
      ;;
  esac
done

# mount ~/secret
if [ "$NEW" = "1" ]; then
  new_secret
fi
if [ "$MOUNT" = "1" ]; then
  check_secret
  mount_secret
fi
# backup secret files into ~/secret

if [ "$UPDATE" = "1" ]; then
  grep -v "^#" "$PATH_CONF" | backup_secret
fi

if [ "$KEEP" != "1" ]; then
  # unmount ~/secret
  unmount_secret
fi

