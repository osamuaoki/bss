#!/bin/sh -e
# vim:set ai si sts=2 sw=2 et tw=79:
# shellcheck disable=SC2004
# -- SC2004 disable globally due to dash weiredness
##############################################################################
# Backup and SnapShot (bss)
# Copyright 2024 (C) Osamu Aoki <osamu@debian.org>
# License: GPL 2+
##############################################################################
# Inheriting parameters (batch subcommand)
##############################################################################
BSS_LOGGER_LEVEL="${BSS_LOGGER_LEVEL:-2}"
BSS_LOGGER_TERMINAL="${BSS_LOGGER_TERMINAL:-1}" # initial value
BSS_LOGGER_JOURNAL="${BSS_LOGGER_JOURNAL:--1}" # initial value
BSS_NOOP="${BSS_NOPE:-}" # set to ":" for no-operation
BSS_TYPE="${BSS_TYPE:-single}" # single, pre, post, hour, ...
BSS_MAY="${BSS_MAY:-false}"
#############################################################################
# system parameters
#############################################################################
PROG_VERSION="@@@VERSION@@@"
PROG_NAME="${0##*/}"
SETX_ON="" # set to "set -x" for trace
SETX_OFF="" # set to "set +x" for trace
EXIT_SUCCESS=0
EXIT_ERROR=1
if [ "$(id -u)" = "0" ]; then
  SUDO=""
else
  if which sudo >/dev/null; then
    SUDO="sudo"
  else
    __echo 0 "Please install 'sudo' and configure it."
    exit $EXIT_ERROR
  fi
fi
#############################################################################
# command and file path parameters (initial values)
#############################################################################
BSS="$PROG_NAME"
BSV="$SUDO btrfs subvolume"
TAR="tar"
GPG="gpg"
RSYNC="$SUDO rsync"
# remote copy uses user account for ssh-key
RSYNC_REMOTE="rsync"
# Use readonly snapshot as the rsync source
# Note on rsync options -a == -rlptgoD
# H: hardlink
# x: one filesystem
# S: sparse
# v: verbose
# z: compress
# less cpu load
RSYNC_OPTA="-aHxS --delete --mkpath"
# less communication bandwidth
RSYNC_OPTR="-aHxSz --delete --mkpath"
# local and --mkpath for gather
RSYNC_OPTG="-aHxS --delete --mkpath"
# rsync /tar verbosity
CMD_OPTV="" # set to "-v" for verbose (BSS_LOGGER_LEVEL=3,4)
#
BSS_DIR=".bss.d"
EXT_CONF="conf"
EXT_FLTR="fltr"
EXT_COPY_PRE="pre_copy_script"
EXT_COPY_POST="post_copy_script"
BSS_STEM=".$BSS"
BSS_CONF="$BSS_STEM.$EXT_CONF"
BSS_FLTR="$BSS_STEM.$EXT_FLTR"
BSS_GATHER=".gather"
BSS_LIST_DIR="${BSS_GATHER}.dir"
BSS_LIST_DIRRC="${BSS_LIST_DIR}rc"
BSS_LIST_GPG="${BSS_GATHER}.gpg"
BSS_LIST_GPGRC="${BSS_LIST_GPG}rc"
PRE_COPY_SCRIPT="$BSS_STEM.$EXT_COPY_PRE"
POST_COPY_SCRIPT="$BSS_STEM.$EXT_COPY_POST"
#############################################################################
# aging parameters
#############################################################################
NOW_TSTR=$(date -u --iso=second)   # time stamp string for NOW
NOW_TEPO=$(date +%s -d"$NOW_TSTR") # unix epoch time (s) for NOW
BSS_NMIN="3"                       # minimum items to keep (initial)
BSS_NMAX="0"                       # maximum items to keep (0 for no_limit)
BSS_TMAX="60*60*24*1000"           # ~3YR    (time to stop aging)
BSS_TMAX_ACTION="keep"             # keep (default) or drop
BSS_TMID="60*60*24*20"             # 20 days (time to actually process snapshots)
BSS_TMID_ACTION="no_filter"        # No filter (it's CPU and SSD consuming)
BSS_TMIN="3*60*60"                 # 3 hours (time to start aging)
BSS_STEP="20"                      # 20 % as aging step
BSS_FMIN="10"                      # minimum required free disk % for snapshot
BSS_COPY_DEST=""
BSS_SNAP_DEST=""                   # normally null
BSS_ZAP_ACTIVE="false"
BSS_FORCE=""
#
#############################################################################
# System Functions (trap)
##############################################################################
# traps
__term_exit () {
  __echo 0 "Process externally interrupted.  Terminating $PROG_NAME."
  exit $EXIT_ERROR
}
trap '__term_exit' HUP INT QUIT TERM
# dash: EXIT (but no ERR)
__err_exit () {
  __echo 0 "Internal process returned an error exit.  Terminating $PROG_NAME."
  exit $EXIT_ERROR
}
__exit_exit () {
  # No error exit
  exit $EXIT_SUCCESS
}
trap '[ $? -eq 0 ] && __exit_exit || __err_exit' EXIT

#############################################################################
# System Variables (CMD_OPTV, BSS_LOGGER_CMD)
##############################################################################
__set_logger () {
  case $BSS_LOGGER_LEVEL in
  0)
    CMD_OPTV="-q"
    ;;
  1)
    CMD_OPTV="-q"
    ;;
  2)
    CMD_OPTV=""
    ;;
  3)
    CMD_OPTV="-v"
    ;;
  4)
    CMD_OPTV="-vv"
    ;;
  5)
    CMD_OPTV="-vvv"
    ;;
  6 | 7)
    CMD_OPTV="-vvvv"
    ;;
  esac
  if [ "$BSS_LOGGER_JOURNAL" = "1" ]; then
    case $BSS_LOGGER_LEVEL in
      0) BSS_LOGGER_CMD="systemd-cat -p 3 -t $PROG_NAME"
        ;;
      1) BSS_LOGGER_CMD="systemd-cat -p 4 -t $PROG_NAME"
        ;;
      2) BSS_LOGGER_CMD="systemd-cat -p 5 -t $PROG_NAME"
        ;;
      3) BSS_LOGGER_CMD="systemd-cat -p 6 -t $PROG_NAME"
        ;;
      4|5|6|7) BSS_LOGGER_CMD="systemd-cat -p 7 -t $PROG_NAME"
        ;;
    esac
  else
    BSS_LOGGER_CMD=""
  fi
}
#############################################################################
# System Functions (__echo and __logger)
##############################################################################
# v--- BSS_LOGGER_JOURNAL_LEVEL
#   v--- SYSTEMD LOGGER_LEVEL
# 0 3 W:   Err       Print error
# 1 4 W:   Warning   Print warning        (-q)
# 2 5 N:   Notice    Print notice only    (normal)
# 3 6 I:   Info      Print verbose output (-v)
# 4 7 D:   Debug     Print Debug output   (-vv)
__echo () {
  $SETX_OFF
  BSS_MSG_LEVEL="$1"
  shift
  if [ "$BSS_LOGGER_LEVEL" -ge "$BSS_MSG_LEVEL" ]; then
    # BSS_LOGGER_JOURNAL == -1 or 0 : disable the systemd journal logging
    # BSS_LOGGER_JOURNAL == 1       : enable the systemd journal logging
    if [ "$BSS_LOGGER_JOURNAL" = "1" ]; then
      case $BSS_MSG_LEVEL in
        0) systemd-cat -p 3 -t "$PROG_NAME" echo "$*"
          ;;
        1) systemd-cat -p 4 -t "$PROG_NAME" echo "$*"
          ;;
        2) systemd-cat -p 5 -t "$PROG_NAME" echo "$*"
          ;;
        3) systemd-cat -p 6 -t "$PROG_NAME" echo "$*"
          ;;
        4|5|6|7) systemd-cat -p 7 -t "$PROG_NAME" echo "$*"
          ;;
      esac
    fi
    # BSS_LOGGER_TERMINAL == -1 or 0 : disable terminal logging
    # BSS_LOGGER_TERMINAL == 1       : enable terminal logging
    if [ "$BSS_LOGGER_TERMINAL" = "1" ]; then
      case $BSS_MSG_LEVEL in
	0) echo "E: $*" >&2
	  ;;
	1) echo "W: $*" >&2
	  ;;
	2) echo "N: $*" >&2
	  ;;
	3) echo "I: $*" >&2
	  ;;
	4|5|6|7) echo "D: $*" >&2
	  ;;
      esac
    fi
  fi
  $SETX_ON
}
__logger () {
  $BSS_NOOP $BSS_LOGGER_CMD "$@"
}
#############################################################################
# System Function (__help)
##############################################################################
# two spaces "  " are meaningful for markdown conversion
__help() {
  cat <<END_OF_HELP
USAGE:
  $BSS [OPTIONS] SUBCOMMAND [PATH [ [ARG]...]
  $BSS SUBCOMMAND [OPTIONS] [PATH [ [ARG]...]

"$BSS" is basically a "btrfs subvolume ..." command wrapper to create and
process historical snapshots with the intuitive snapshot subvolume name and
flexible data aging capabilities.  (Some subcommands can work with ext2/3/4fs,
too.)

"$BSS" operates mostly on the btrfs subvolume pointed by the first optional
argument "PATH".  "PATH" can point to anywhere within this source btrfs
subvolume.  The default value for "PATH" is the current working directory (".")
when it is missing.  The internal variable "\$FS_BASE" is the BASE directory of
this source btrfs subvolume.  (The use of tailing "/" in "PATH" is
insignificant and deprecated.)

"$BSS snapshot [PATH]" starts "snapshot" operation to create a btrfs readonly
snapshot of the source btrfs subvolume using "btrfs subvolume snapshot -r ...".
The snapshot subvolume is named with ISO 8601 timestamp and TYPE specifier,
e.g.  '2020-09-02T11:51:50+00:00.single' and placed normally in the "$BSS_DIR/"
directory relative to the "\$FS_BASE" directory since BSS_SNAP_DEST" specified
in "$BSS_CONF" is null string.  This normal snapshot mode is intended to be
used for the user data.

"$BSS snapshot [PATH]" can place its snapshots outside of the "\$FS_BASE"
directory by specifying "BSS_SNAP_DEST" in "$BSS_CONF" to point to somewhere on
the same btrfs but outside of the "\$FS_BASE" directory.  This system snapshot
mode is intended to be used for the system data.

"$BSS process [PATH]" starts "process" operation to process existing snapshots
generated by "$BSS" according to their age.  "$BSS" checks the time interval
between them from the older ones to newer ones and makes them more sparse for
the older ones by removing some of them using parameters in "$BSS_CONF" in the
"$BSS_DIR/" directory.  This involves following actions:

  * Secure minimum required free blocks (minimum FMIN %).
  * Keep initial few (NMIN) snapshots unconditionally.
  * Limit the maximum number of snapshots to NMAX.
    * NMAX=0 is the special case and means no limit for number of snapshots.
  * Before TMIN, keep snapshots unconditionally.
  * Age snapshots with basically exponentially growing intervals with the
    specified ratio (STEP 2%-90%).
  * After TMID, age snapshots more aggressively.
    * Special handlings to keep some high priority snapshots stop.
    * If TMID_ACTION=filter, content files of snapshots are filtered with the
      script "$BSS_FLTR" at the "$BSS_DIR/" directory.
  * After TMAX, stop aging snapshots.
    * TMAX=0 is the special case and means no limit for aging.
    * If TMAX_ACTION=drop, drop subvolume after TMAX.
    * If TMAX_ACTION=keep, keep subvolume after TMAX.

OPTIONS:

  -t,--type TYPE  use TYPE instead of the default "single" for the snapshot
                  type.  If \$BSS_TYPE is exported to $BSS, its value is used
                  as the default for TYPE instead. The automatic snapshot uses
                  "pre" (before APT), "post (after APT), "hour" (on boot and
                  every hour). If "keep" is specified, the snapshot with it
                  will be kept forever under the normal aging process.
  -c,--conf RC    use "RC.$EXT_CONF", "RC.$EXT_FLTR" etc. instead of their
                  default "$BSS_CONF", "$BSS_FLTR" etc.
  -f,--force      force to reapply filter
  -n,--noop       no file nor filesystem modification by prepending pertinent
                  internal commands with "echo __"
  -h,--help       show this help
  --version       show version
  -l,--logger     enable systemd logger (default for active subcommands)
  -L,--nologger   disable systemd logger (default for passive subcommands)
  -m,--may        may execute snapshot or gather if possible
  -q,--quiet      quiet (no notice messages, just warn/error messages)
  -v,--verbose    verbose (with info messages)
  -vv             very verbose for debug (with info and debug messages)
  -x              trace on (trace shell code for debug)

SUBCOMMAND:

  snapshot   make a readonly snapshot normally in the relative path "$BSS_DIR/"
             as "<ISO_8601_date>.<TYPE>"  (The default type is "single")
  list       list all snapshots
  age        assess aging status of all snapshots
  overview   overview of all snapshots (wrapper for "$BSS -v age >/dev/null")
  process    process snapshots according to their aging status
  copy       copy subvolume at the BASE directory (1st argument) to the
             (remote) destination (2nd argument) using rsync
  gather     gather local files and directories to based on:
               * ".gather.dirrc" file to the ".gather.dir" directory
               * ".gather.gpgrc" file to the ".gather.gpg" encrypted archive
  filter     create a filtered snapshot from the specified snapshot in
             "$BSS_DIR/" as "<specified_subvol_name>_filter"
  revert     make snapshot "<ISO_8601_date>.last" and replace the subvolume at
             the BASE directory (1st argument) with the specified snapshot
             "<ISO_8601_date>.<extension>" (2nd argument) found under
             "BSS_SNAP_DEST" specified in "$BSS_CONF".  This is intended only
             for the system snapshot mode. (This is experimental and untested
             feature with limited capabilities.  Use with extra care!)
  zap        zap (=delete) particular snapshot(s) specified by its arguments
             ("zap" is required to be typed in full text)
  template   make template files in the "$BSS_DIR/" directory:
               * "$BSS_CONF" (aging rule)
               *  "$BSS_FLTR[.disabled]" (filtering rule)
  batch FNB  change the current working directory to the user's home directory
             and source the shell script found at:
               *  "\$XDG_CONFIG_HOME/$BSS/FNB" (non-root, \$XDG_CONFIG_HOME set)
               *  "~/.config/$BSS/FNB" (non-root, \$XDG_CONFIG_HOME unset)
               *  "/etc/$BSS/FNB" (root)
  BASE       print the BASE directory for "$BSS"
  jobs       list all systemd timer schedule jobs for $BSS


ARGUMENTS:

SUBCOMMANDs may be shortened to a single character.

For some SUBCOMMANDs, enxtra optional arguments after the explicit "PATH" may
be specified to provide arguments to them.

For "$BSS list", you may add the second argument to match snapshot "<TYPE>".
"$BSS list . '(s.*|h.*)' " should list snapshots with both "single" and "hour"
types.

For "$BSS copy BASE DEST_PATH", this is a combination of "$BSS snapshot" to
create a snapshot of the BASE directory to "SOURCE_PATH" and a wrapper for
"$RSYNC" command with its first argument "SOURCE_PATH" and the second argument
"DEST_PATH".  This command is smart enough to skip the "$BSS_DIR/" directory to
allow independent management of data using "$BSS" on both the BASE directory
and "DEST_PATH". (The tailing "/" in "DEST_PATH" is removed.)

If "DEST_PATH" is a local path such as "/srv/backup", then "$RSYNC $RSYNC_OPTA"
is used to have enough privilege and to save the CPU load.  If this local
"DEST_PATH" doesn't exist, it is created in advance as:

 * a subvolume if it is on btrfs or, 
 * a subdirectory if it is on ext4 filesystem.

If "DEST_PATH" is a local relative path without the leading  "/", then it is
treated as a relative path from the user's home directory.

If "DEST_PATH" is a remote path such as "[USER@]HOST:DEST_PATH", then
"$RSYNC_REMOTE $RSYNC_OPTR" is used to limit privilege and to save the network
load. Also, this allows "$BSS copy" to use the SSH-key stored under "~/.ssh/".

"$BSS zap" always operates on the current working directory as "PATH".  Thus
the first argument is not "PATH" but one of following action specifies:

  new           zap (=delete) the newest snapshot subvolume
  old           zap the oldest snapshot subvolume
  half          zap the older half of snapshot subvolumes
  <subvolume>   zap specified snapshot subvolume (path with or without
                ".../$BSS_DIR/" such as "2020-01-01T00:00:00+00:00.single").
                Multiple subvolumes may be specified.

Unless you have specific reasons to use "$BSS zap", you should consider to use
"$BSS process" to prune outdated snapshots.

For "$BSS revert PATH PATH_OLD", subvolume at PATH is replaced by the subvolume
at "PATH_OLD".  "PATH" can't be set to "/".

NOTE:

This "$BSS" command comes with examples for systemd scripts and apt hook script
to enable automatic "snapshot" operations.  This "$BSS" command also comes with
examples for systemd scripts to enable automatic daily "process" operation.

For some snapshots, different "TYPE" values may be used instead of its default
"single".

  TYPE="pre"   automatic "snapshot" operation just before APT update
  TYPE="post"  automatic "snapshot" operation just after  APT update
  TYPE="copy"  automatic "snapshot" operation just before "$BSS copy"
  TYPE="hour"  automatic "snapshot" operation on boot and every hour
  TYPE="last"  automatic "snapshot" operation just before "$BSS revert"

This "$BSS" calculates time values related to age in the second and prints them
in the DAYS.HH:MM:SS format (HH=hour, MM=minute, SS=second).

You can make a snapshot just by "$BSS" alone.

You can use verbose "$BSS -v BASE" command to print current effective
configuration parameters without side effects.

This "$BSS" command can use systemd logger.  If usedm you can check results of
its recent invocations with:

  $ journalctl -a -b -t bss
  $ journalctl -f -t bss

CAVEAT:

The source filesystem must be btrfs for many subcommands.

The non-root user who executes this command must be a member of "sudo".

Running filter script "$BSS_FLTR" drains CPU and SSD resources but it may save
SSD usage size significantly.  If you are not interested in reducing SSD usage
size by this script, rename from "$BSS_FLTR" to "$BSS_FLTR.disabled" and set
BSS_TMID_ACTION="no_filter" in "$BSS_CONF".

The "revert" operation is supported only for the system snapshot mode which
sets BSS_SNAP_DEST in "$BSS_CONF" to non-zero string.  APT updates can be
configured to create snapshots of the system using this system snapshot mode.
The "revert" operation can bring the system before the APT update operation.
This kind of "revert" operation must be performed from the secondary system on
another root filesystem and all subvolumes to be manipulated shouldn't be
accessed by other processes. You should manually mount using "/etc/fstab" for
all subvolumes under the subvolume to run "revert" operation and manage them
separately to keep the system recoverable since the snapshot operation isn't
recursive.

Although this "$BSS" focuses on btrfs, there is minimal support for ext2/ext3
(this includes ext4) for "$BSS copy ...", "$BSS gather ...", and "$BSS
template" which runs the "rsync" command as the backend of subcommands.

Copyright 2022 - 2024 Osamu Aoki <osamu@debian.org>, GPL 2+
END_OF_HELP
}

__version() {
  cat <<EOM
$PROG_NAMR ($PROG_VERSION)

Copyright (C) 2021-2024 Osamu Aoki <osamu@debian.org>

License GPLv2+: GNU GPL version 2 or later
<https://gnu.org/licenses/gpl-2.0.html>.  This is free software: you are free
to change and redistribute it.  There is NO WARRANTY, to the extent permitted
by law.

Written by Osamu Aoki.
EOM
}

##############################################################################
# @brief             convert $1 in seconds to day.hh:mm:ss string
# @arg   $1          seconds
# @echo              "day.hh:mm:ss" string
##############################################################################
age_string() {
  # @ $1 second
  SEC="$(($1))"
  MIN=$((SEC / 60))
  SEC=$((SEC % 60))
  HR=$((MIN / 60))
  MIN=$((MIN % 60))
  DAY=$((HR / 24))
  HR=$((HR % 24))
  printf "%2i.%02i:%02i:%02i" "$DAY" "$HR" "$MIN" "$SEC"
}

##############################################################################
# This is basically executed from this host
##############################################################################
# set FS_BASE, FS_TYPE, FS_BASE_*, BSS_* parameters
##############################################################################
__set_fs_base() {
  FS_BASE="$($SUDO stat -c %m "$FS_BASE0")"
  FS_TYPE="$($SUDO stat -f -c %T "$FS_BASE")"
  if [ "$FS_TYPE" != "btrfs" ] && [ "$FS_TYPE" != "ext2/ext3" ]; then
    __echo 0 "S: unsupported filesystem $FS_TYPE: $FS_BASE0 (mounted at $FS_BASE)"
    exit $EXIT_ERROR
  fi
# FS_BASE is clean canonical absolute path pointing to the root of filesystem
# containing FS_BASE0
  FS_BASE_MOD="755"
  FS_BASE_UID=$($SUDO stat -c %u "$FS_BASE")
  FS_BASE_GID=$($SUDO stat -c %g "$FS_BASE")
# derivative parameters
  BSS_DIR_BASE="$FS_BASE/$BSS_DIR"
  BSS_CONF_BASE="$BSS_DIR_BASE/$BSS_CONF"
  BSS_FLTR_BASE="$BSS_DIR_BASE/$BSS_FLTR"
  BSS_PRE_COPY_SCRIPT_BASE="$BSS_DIR_BASE/$PRE_COPY_SCRIPT"
  BSS_POST_COPY_SCRIPT="$BSS_DIR_BASE/$POST_COPY_SCRIPT"
}
##############################################################################
# load parameters
##############################################################################
__load_config() {
  __echo 4 "C: BSS_NOOP            = '$BSS_NOOP'"
  __echo 4 "C: BSS_CONF            = '$BSS_CONF'"
  __echo 4 "C: BSS_FLTR            = '$BSS_FLTR'"
  __echo 4 "C: BSS_LIST            = '$BSS_LIST'"
  __echo 4 "C: BSS_TYPE            = '$BSS_TYPE'"
  __echo 4 "C: BSS_LOGGER_LEVEL    = '$BSS_LOGGER_LEVEL'"
  __echo 4 "C: BSS_LOGGER_TERMINAL = '$BSS_LOGGER_TERMINAL'"
  __echo 4 "C: BSS_LOGGER_JOURNAL  = '$BSS_LOGGER_JOURNAL'"
  __echo 3 "Run '$BSS $BSS_COMMAND' on BASE=$FS_BASE (inode=256) $FS_BASE_UID:$FS_BASE_GID"
  if [ -r "$BSS_CONF_BASE" ]; then
    __echo 3 "    configuration at    $BSS_CONF_BASE"
  else
    __echo 0 "C:  configuration missing, please use '$BSS template $FS_BASE'"
    exit $EXIT_ERROR
  fi
  if [ -r "$BSS_FLTR_BASE" ]; then
    __echo 3 "    filter        at    $BSS_FLTR_BASE"
  else
    __echo 3 "    filter  missing     (probably OK)."
  fi
  __echo 3 "Ensure to run a single instance of $BSS (wait up to 30 sec)"
  # fd=9 not used elsewhere in this script. (/ home, ... starts this script)
  exec 9<"$0"
  if ! flock --wait 30 9; then
    __echo 0 "C: $BSS already running.  Try later"
    exit 2
  fi
  __echo 3 "No other instance of $BSS found"
  # make sure BSS_DIR_BASE=FS_BASE/BSS_DIR=FS_BASE/.bss.d exists
  if [ ! -d "$BSS_DIR_BASE" ]; then
    __echo 0 "C: $BSS is not configured."
    __echo 0 "C:   * Use '$BSS template' and edit generated template files first."
    __echo 0 "C:"
    __help
    exit $EXIT_ERROR
  fi
  # ensure proper permissions
  __echo 3 "Set permissions to $FS_BASE_UID:$FS_BASE_GID $FS_BASE_MOD for $BSS_DIR_BASE"
  # match owner with the parent directory
  __logger $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$BSS_DIR_BASE"
  __logger $SUDO chmod "$FS_BASE_MOD" "$BSS_DIR_BASE"
  if [ -r "$BSS_CONF_BASE" ]; then
    # shellcheck disable=SC1090
    . "$BSS_CONF_BASE"
    __echo 4 "C: Sourced $BSS_CONF for BASE=$FS_BASE"
  fi
  # normalize and sanity check parameters (ensure gaps TMIN TMID TMAX etc.)
  if [ "$BSS_NMIN" -lt "1" ]; then
    __echo 1 "Avoid awkward situation NMIN=$BSS_NMIN < 1, force NMIN=1"
    BSS_NMIN="1"
  fi
  if [ "$BSS_NMAX" -lt "0" ]; then
    __echo 1 "Avoid awkward situation NMAX=$BSS_NMAX < 0, force NMAX=0 (no_limit)"
    BSS_NMAX="0"
  fi
  BSS_TMIN=$(($BSS_TMIN))
  if [ "$BSS_TMIN" -lt "60" ]; then
    __echo 1 "Avoid awkward situation TMIN=$BSS_TMIN < 60, force TMIN=60"
    BSS_TMIN="60"
  fi
  BSS_TMID=$(($BSS_TMID))
  if [ "$BSS_TMID" -lt "$(($BSS_TMIN * 2))" ]; then
    __echo 1 "Avoid awkward situation TMID=$BSS_TMID < TMIN*2=$BSS_TMIN*2, force TMID=$(($BSS_TMIN * 2))"
    BSS_TMID="$(($BSS_TMIN * 2))"
  fi
  BSS_TMAX=$(($BSS_TMAX))
  if [ "$BSS_TMAX" != "0" ] && [ "$BSS_TMAX" -lt "$BSS_TMID" ]; then
    __echo 1 "Avoid awkward situation TMAX=$BSS_TMAX < TMID*2=$BSS_TMID*2, force TMAX=$(($BSS_TMID * 2))"
    BSS_TMAX="$(($BSS_TMID * 2))"
  fi
  BSS_STEP=$(($BSS_STEP))
  if [ "$BSS_STEP" -lt "2" ]; then
    __echo 1 "Aging step too small, force STEP=2% (i.e. 1.02x age ratio from the younger one)"
    BSS_STEP=2
  elif [ "$BSS_STEP" -gt "90" ]; then
    __echo 1 "Aging step too big, force STEP=90% (i.e. 10x age ratio from the younger one)"
    BSS_STEP=90
  fi
  # normalize
  if [ "$BSS_TMAX_ACTION" = "drop" ]; then
    BSS_TMAX_ACTION="drop"
  else
    BSS_TMAX_ACTION="keep"
  fi
  if [ "$BSS_TMID_ACTION" = "filter" ]; then
    BSS_TMID_ACTION="filter"
  else
    BSS_TMID_ACTION="no_filter"
  fi
  if [ "$BSS_TMAX_ACTION" = "drop" ] && [ "$BSS_TMAX" = "0" ]; then
    __echo 1 "TMAX_ACTION is 'drop' despite TMAX=0 (no_limit), force to change TMAX_ACTION to 'keep'"
    BSS_TMAX_ACTION="keep"
  fi
  if [ "$BSS_TMID_ACTION" != "filter" ] && [ -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "TMID_ACTION=no_filter but unused filter $BSS_FLTR exists for BASE=$FS_BASE"
  fi
  if [ "$BSS_TMID_ACTION" = "filter" ] && [ ! -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "Force TMID_ACTION=no_filter since $BSS_FLTR is missing for BASE=$FS_BASE"
    BSS_TMID_ACTION="no_filter"
  fi
  # Human readable string
  S_NMIN="$BSS_NMIN"
  if [ "$BSS_NMAX" = "0" ]; then
    S_NMAX="no_limit"
  else
    S_NMAX="$BSS_NMAX"
  fi
  S_TMIN="$(age_string "$BSS_TMIN")"
  S_TMID="$(age_string "$BSS_TMID")"
  if [ "$BSS_TMAX" = "0" ]; then
    S_TMAX="no_limit"
  else
    S_TMAX="$(age_string "$BSS_TMAX")"
  fi
  if [ -z "$BSS_SNAP_DEST" ]; then
    # snapshot visible from the original FS
    BSS_SNAP_DEST_BASE="$BSS_DIR_BASE"
  else
    # snapshot non-visible from the original FS
    BSS_SNAP_DEST_BASE="$BSS_SNAP_DEST"
  fi
  __echo 3 "snapshot source: BASE=$FS_BASE"
  __echo 3 "snapshot destination: BSS_SNAP_DEST_BASE=$BSS_SNAP_DEST_BASE"
  __echo 3 "NMAX = '$BSS_NMAX' = $S_NMAX (maximum number of SV to keep)"
  __echo 3 "NMIN = '$BSS_NMIN' = $S_NMIN (minimum number of SV to keep)"
  __echo 3 "TMAX = '$BSS_TMAX' = $S_TMAX (time to stop aging)"
  __echo 3 "TMID = '$BSS_TMID' = $S_TMID (time to stop prioritizing and optionally apply filter)"
  __echo 3 "TMIN = '$BSS_TMIN' = $S_TMIN (time to start aging SV)"
  __echo 3 "STEP = '$BSS_STEP'% (age gap ratio to keep a newer SV, (age_gap_ratio) = (age_old - age_new)/age_old"
  __echo 3 "    STEP maximum     $(age_string $(($BSS_TMAX * $BSS_STEP / 100)))"
  __echo 3 "    STEP middle      $(age_string $(($BSS_TMID * $BSS_STEP / 100)))"
  __echo 3 "    STEP minimum     $(age_string $(($BSS_TMIN * $BSS_STEP / 100)))"
  __echo 3 "TMAX_ACTION = '$BSS_TMAX_ACTION' (action at TMAX)"
  __echo 3 "TMID_ACTION = '$BSS_TMID_ACTION' (action at TMID)"
  __echo 3 "FMIN = '$BSS_FMIN'% (minimum required free disk % for snapshot)"
}

##############################################################################
__snapshot() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    if $BSS_MAY ; then
      __echo 1 "Skip snapshot since FS=$FS_TYPE, BASE=$FS_BASE (may)"
      exit $EXIT_SUCCESS
    else
      __echo 0 "S: wrong filesystem FS=$FS_TYPE, BASE=$FS_BASE"
      exit $EXIT_ERROR
    fi
  fi
  # disk size sanity check without quota consideration
  BSS_STAT_TOTAL=$(stat -f -c %b "$FS_BASE")
  # Even on 4k block system, disk with 200 blocks is less than 1MB
  if [ "$BSS_STAT_TOTAL" -le 200 ]; then
    __echo 0 "S: total disk size: $BSS_STAT_TOTAL blocks (too small, minimum required 200)"
    __echo 0 "S: no snapshot: BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    exit $EXIT_ERROR
  fi
  BSS_STAT_UNIT=$((BSS_STAT_TOTAL / 100))
  BSS_STAT_FREE=$(stat -f -c %f "$FS_BASE")
  BSS_FREE_UNIT=$((BSS_STAT_FREE / BSS_STAT_UNIT))
  BSS_FMIN_PRE=$(($BSS_FMIN + 20))
  if [ "$BSS_FREE_UNIT" -le "$BSS_FMIN" ]; then
    __echo 0 "S: free disk space: $BSS_FREE_UNIT%  (too small, minimum required FMIN=$BSS_FMIN%)"
    __echo 0 "S: skip snapshot: BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    exit $EXIT_ERROR
  elif [ "$BSS_FREE_UNIT" -lt "$BSS_FMIN_PRE" ]; then
    __echo 2 "Free disk space: $BSS_FREE_UNIT%  (enough, minimum required FMIN=$BSS_FMIN%)"
  else
    __echo 3 "Free disk space: $BSS_FREE_UNIT%  (enough, minimum required FMIN=$BSS_FMIN%)"
  fi
  # make snapshot (avoid the same time stamp)
  while [ -d "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}" ]; do
    sleep "1s"
    NOW_TSTR=$(date -u --iso=second)
  done
  if [ -z "$BSS_SNAP_DEST" ]; then
    __echo 2 "Make snapshot (user mode): BASE=$FS_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    # normal mode
    # shellcheck disable=SC2086
    __logger $BSV snapshot -r "$FS_BASE" "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}"
  else
    __echo 2 "Make snapshot (system snapshot mode): BASE=$FS_BASE DEST=$BSS_SNAP_DEST_BASE TIME=${NOW_TSTR} TYPE=${BSS_TYPE}"
    # system snapshot mode
    # shellcheck disable=SC2086
    __logger $BSV snapshot "$FS_BASE" "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}"
    if [ "$($BSV list -o "$FS_BASE" | wc -l)" != 0 ]; then
      __echo 1 "snapshot source contains nested subvolumes as follows.  Data in them are not in the snapshot taken."
      __logger $BSV list -o "$FS_BASE"
    fi
  fi
}

##############################################################################
RE_ISO='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}[-+]00:00'
__list() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "L: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      .* (egrep pattern)
  # $2      "-r" for reverse, "" for normal
  # STDOUT  snapshot time stamps
  # STDERR  debug output
  __echo 4 "L: snapshots for BASE=$FS_BASE matching TYPE_REGEX='${1}' (${2})"
  if [ -d "$BSS_SNAP_DEST_BASE" ]; then
    cd "$BSS_SNAP_DEST_BASE" >/dev/null
    # shellcheck disable=SC2086
    { ls -1d ${2} -- * 2>/dev/null || true; } |
      grep -E "^$RE_ISO\.${1}\$" || true
  else
    __echo 0 "L: no 'list' since snapshot directory $BSS_SNAP_DEST_BASE is missing for BASE=$FS_BASE"
    exit $EXIT_ERROR
  fi
}

##############################################################################
__age() {
  # use STDOUT for age assessment result
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "A: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE"
    exit $EXIT_ERROR
  fi
  # snapshot time stamps with + or - prepended
  __echo 4 "A: aging status of snapshots for BASE=$FS_BASE"
  BSS_TSTEP=$((BSS_TMAX * BSS_STEP / 100))
  # search in direction: old -> new
  BSS_LIST="$(__list '.*')" # ignore debug output
  BSS_N="$(echo "$BSS_LIST" | wc -w)"
  # count down
  BSS_I="$BSS_N"
  BSS_TLAST="-1" # Initial value place holder for-loop
  for BSS_SV in $BSS_LIST; do
    # Scan                     Scan from Old to New
    # Time   Old    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  New
    # Epoch  Small  --------------------------------------  Large
    # I             N-1 ................................ 0
    # LAST          BSS_TEPO(LAST)              NOW_TEPO   diff=TLAST
    # THIS             BSS_TEPO(THIS)           NOW_TEPO   diff=TAGE
    BSS_I=$((BSS_I - 1))
    __echo 4 "A: I=$BSS_I subvolume=$BSS_SV"
    BSS_TSTR="${BSS_SV%%.*}"  # timestamp string for SV
    BSS_TYPE="${BSS_SV##*.}"
    BSS_EXTRA="${BSS_TYPE##*_}"
    if [ "$BSS_EXTRA" = "$BSS_TYPE" ]; then
      BSS_EXTRA=""
    fi
    BSS_TEPO=$(date '+%s' -d"$BSS_TSTR")  # unix epoch time (s) for SV
    BSS_TAGE=$((NOW_TEPO - BSS_TEPO))  # age (s) of SV
    if [ "$BSS_TLAST" = "-1" ]; then
      # Ensure to keep the oldest SV
      BSS_TLAST="$(($BSS_TAGE + $BSS_TSTEP * 2))"  # large fake age (s) of last SV
    fi
    S_TAGE="$(age_string $BSS_TAGE)"  # age string of SV
    # delta age of SV in seconds from last SV kept
    BSS_TDEL=$((BSS_TLAST - BSS_TAGE))  # age delata (s) from last SV to this SV
    S_TDEL="$(age_string $BSS_TDEL)"  # age delata string from last SV to this SV
    S_TSTEP="$(age_string $BSS_TSTEP)"  # step string
    __echo 4 "A: AGE=$BSS_TAGE=$S_TAGE LAST=$BSS_TLAST DEL=$BSS_TDEL=$S_TDEL STEP=$BSS_TSTEP=$S_TSTEP"
    #########################################################################
    # Index rules (no use to update TLAST, TDEL)
    #########################################################################
    #########################################################################
    # Keep
    # Classify: I < NMIN
    #########################################################################
    if [ "$BSS_I" -lt "$BSS_NMIN" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE, I=$BSS_I <  NMIN=$S_NMIN (keep)"
      echo "+++_$BSS_SV"
    #########################################################################
    # Keep
    # Classify: TAGE < TMIN
    #########################################################################
    elif [ "$BSS_TAGE" -lt "$BSS_TMIN" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE <  TMIN=$S_TMIN (keep)"
      echo "+++_$BSS_SV"
    #########################################################################
    # Keep
    # Classify: TYPE = keep
    #########################################################################
    elif [ "$BSS_TYPE" = "keep" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE (keep: by TYPE)"
      echo "+++_$BSS_SV"
      if [ "$BSS_TAGE" -ge "$BSS_TMAX" ]; then
        BSS_TLAST="$BSS_TAGE"
      else
        BSS_TLAST="$BSS_TAGE"
        BSS_TSTEP=$((BSS_TLAST * BSS_STEP / 100))
      fi
    #########################################################################
    # Drop
    # Classify: I > NMAX and NMAX > 0, i.e., except for no_limit
    #########################################################################
    elif [ "$BSS_I" -ge "$BSS_NMAX" ] && [ "$BSS_NMAX" -gt "0" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE, $BSS_I >= NMAX=$S_NMAX (drop)"
      echo "---_$BSS_SV"
    #########################################################################
    # TMAX or older (keep step when keeping snapshot)
    #########################################################################
    #########################################################################
    # Drop action=drop
    # Classify: TAGE >= TMAX and TMAX_ACTION=drop (TMAX>0 pre checked)
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX_ACTION" = "drop" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX, (TMAX_ACTION=$BSS_TMAX_ACTION)"
      echo "---_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMAX and TMAX>0 and TYPE = post or last
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && { [ "$BSS_TYPE" = "post" ] || [ "$BSS_TYPE" = "last" ]; }; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX (drop: special TYPE)"
      echo "---_$BSS_SV"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX, DEL=$S_TDEL <  STEP=$S_TSTEP (drop: dense)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse as filtered
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL => TSTEP and TMID_ACTION=filter
    # Here, MAX_ACTION != drop -> keep -> filtered or no-filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" = "filter" ]; then
      __echo 3 "###_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX, DEL=$S_TDEL >= STEP=$S_TSTEP, EXTRA=$BSS_EXTRA (TMID_ACTION=$BSS_TMID_ACTION: sparse, keep step)"
      echo "###_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Keep sparse without filter
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL => TSTEP and TMID_ACTION != filter
    # Here, MAX_ACTION != drop -> keep -> filtered or no-filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" != "filter" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX, DEL=$S_TDEL >= STEP=$S_TSTEP (TMID_ACTION=$BSS_TMID_ACTION: sparse, keep step)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMAX and TMAX>0 and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMAX" ] && [ "$BSS_TMAX" -gt "0" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMAX=$S_TMAX, DEL=$S_TDEL <  STEP=$S_TSTEP (drop: dense, keep step)"
      echo "---_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
    #########################################################################
    # TMID or older (update step when keeping snapshot)
    #########################################################################
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMID and TYPE = post or last
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && { [ "$BSS_TYPE" = "post" ] || [ "$BSS_TYPE" = "last" ]; }; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMID=$S_TMID (drop: special TYPE)"
      echo "---_$BSS_SV"
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMID and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMID=$S_TMID, DEL=$S_TDEL <  STEP=$S_TSTEP (drop: dense)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse with filter
    # Classify: TAGE >= TMID and TDEL => TSTEP and TMID_ACTION=filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" = "filter" ]; then
      __echo 3 "###_$BSS_SV AGE=$S_TAGE >= TMID=$S_TMID, DEL=$S_TDEL >= STEP=$S_TSTEP, EXTRA=$BSS_EXTRA (TMID_ACTION=$BSS_TMID_ACTION: sparse, update step)"
      echo "###_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST * BSS_STEP / 100))
    #########################################################################
    # Keep sparse without filter
    # Classify: TAGE >= TMID and TDEL => TSTEP and TMID_ACTION != filter
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMID" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ] && [ "$BSS_TMID_ACTION" != "filter" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE >= TMID=$S_TMID, DEL=$S_TDEL >= STEP=$S_TSTEP (TMID_ACTION=$BSS_TMID_ACTION: sparse, keep step)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST * BSS_STEP / 100))
    #########################################################################
    # TMIN or older
    #########################################################################
    #########################################################################
    # Drop special TYPE
    # Classify: TAGE >= TMIN and TYPE = post
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TYPE" = "post" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMIN=$S_TMIN (drop: special TYPE)"
      echo "---_$BSS_SV"
    #########################################################################
    # Keep sparse
    # Classify: TAGE >= TMIN and TDEL > TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TDEL" -ge "$BSS_TSTEP" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE >= TMIN=$S_TMIN, DEL=$S_TDEL >= STEP=$S_TSTEP (keep: sparse, update step)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST * BSS_STEP / 100))
    #########################################################################
    # Keep special TYPE
    # Classify: TAGE >= TMIN and TYPE = last
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TYPE" = "last" ]; then
      __echo 3 "+++_$BSS_SV AGE=$S_TAGE >= TMIN=$S_TMIN (keep: special TYPE, update step)"
      echo "+++_$BSS_SV"
      BSS_TLAST="$BSS_TAGE"
      BSS_TSTEP=$((BSS_TLAST * BSS_STEP / 100))
    #########################################################################
    # Drop dense
    # Classify: TAGE >= TMIN and TDEL < TSTEP
    #########################################################################
    elif [ "$BSS_TAGE" -ge "$BSS_TMIN" ] && [ "$BSS_TDEL" -lt "$BSS_TSTEP" ]; then
      __echo 3 "---_$BSS_SV AGE=$S_TAGE >= TMIN=$S_TMIN, DEL=$S_TDEL <  STEP=$S_TSTEP (drop: dense)"
      echo "---_$BSS_SV"
    #########################################################################
    # NO WAY
    #########################################################################
    # Classify: ???
    #########################################################################
    else # This should never reached
      __echo 1 "???_$BSS_SV AGE=$S_TAGE, DEL=$S_TDEL, I=$BSS_I (strange)"
      exit $EXIT_SUCCESS
    fi
  done
}

##############################################################################
__process() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "P: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  __echo 2 "Process snapshots: BASE=$FS_BASE TIME=$NOW_TSTR"
  BASE_BSS_LOGGER_LEVEL="$BSS_LOGGER_LEVEL"
  if [ "$BSS_LOGGER_LEVEL" -le "3" ]; then
    __echo 2 "Assess aging internally for process: $FS_BASE (silenced except for debug)"
    BSS_LOGGER_LEVEL="1" # Force __age to be quieter 3=='-v',2=='' -> 1=='-q'
  fi
  for XBSS_SV in $(__age 2>/dev/null ); do
  # STDOUT is age assessment result
    BSS_LOGGER_LEVEL="$BASE_BSS_LOGGER_LEVEL"
    # drop first character + or - or #
    BSS_SV="${XBSS_SV#???_}"
    BSS_TSTR="${BSS_SV%%.*}"
    BSS_TYPE="${BSS_SV##*.}"
    BSS_EXTRA="${BSS_TYPE##*_}"
    if [ "$BSS_EXTRA" = "$BSS_TYPE" ]; then
      BSS_EXTRA=""
    fi
    BSS_TEPO=$(date '+%s' -d"$BSS_TSTR")
    BSS_TAGE=$((NOW_TEPO - BSS_TEPO)) # age of SV in seconds
    S_TAGE="$(age_string $BSS_TAGE)"
    if [ -z "${XBSS_SV%%---_*}" ]; then
      __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE"
      # shellcheck disable=SC2086
      __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    elif [ -z "${XBSS_SV%%+++_*}" ]; then
      __echo 3 "Keep snapshot: BASE=$FS_BASE SV=$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_EXTRA" != "filter" ]; then
      __echo 2 "Filter snapshot: BASE=$FS_BASE SV=$BSS_SV -> ${BSS_SV}_filter AGE=$S_TAGE"
      __filter "$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_FORCE" = "FORCE" ]; then
      __echo 2 "Filter snapshot again: BASE=$FS_BASE SV=$BSS_SV -> ${BSS_SV} AGE=$S_TAGE"
      __filter "$BSS_SV"
    elif [ -z "${XBSS_SV%%###_*}" ] && [ "$BSS_EXTRA" = "filter" ]; then
      __echo 3 "Keep snapshot (filtered): BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE"
    else
      __echo 1 "???? snapshot: BASE=$FS_BASE SV=$BSS_SV AGE=$S_TAGE (strange)"
    fi
  done
}

##############################################################################
__jobs() {
  # $1 == --all or none
  # interactive use only
  echo " $ systemctl --system --all list-timers 'bss-*'"
  systemctl --system --all list-timers 'bss-*'
  echo
  echo " $ systemctl --user --all list-timers 'bss-*'"
  systemctl --user --all list-timers 'bss-*'
  echo
  echo '# See journal with "journalctl -a -b -t bss" or "journalctl -f -t bss"'
}

##############################################################################
__filter() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "F: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      SV to be filtered
  # Execution of filter $BSS_FLTR and snapshot operation are expected to be
  # heavy on CPU and SSD usage.
  BSS_SV="${1}"
  BSS_SV0="${BSS_SV%_filter}"
  # sanity check first
  if [ ! -r "$BSS_FLTR_BASE" ]; then
    __echo 1 "Do nothing since $BSS_FLTR is missing for BASE=$FS_BASE"
    exit $EXIT_SUCCESS
  elif [ -d "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw" ]; then
    __echo 0 "F: Pre-existing ${BSS_SV0}_rw blocks filter BASE=$FS_BASE SV=$BSS_SV"
    exit $EXIT_ERROR
  elif [ "$BSS_FORCE" != "FORCE" ] && [ -d "$BSS_SNAP_DEST_BASE/${BSS_SV0}_filter" ]; then
    __echo 0 "F: Pre-existing ${BSS_SV0}_filter blocks filter BASE=$FS_BASE SV=$BSS_SV"
    exit $EXIT_ERROR
  else
    __echo 4 "F: filter snapshot of BASE=$FS_BASE SV=$BSS_SV with $BSS_FLTR"
    # shellcheck disable=SC2086
    __logger $BSV snapshot "$BSS_SNAP_DEST_BASE/$BSS_SV/" "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw"
    # filter snapshot subvolume contents
    # shellcheck disable=SC2086
    {
      __logger cd "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw"
      __logger $SUDO sh <"$BSS_FLTR_BASE" || $BSS_MAY
    }
    # remove the original snapshot now for --force
    if [ "$BSS_SV" != "$BSS_SV0" ]; then
      # subvolume already filtered
      if [ "$BSS_FORCE" = "FORCE" ]; then
        # shellcheck disable=SC2086
        __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      else
        __echo 0 "F: use '--force' to filter BASE=$FS_BASE SV=$BSS_SV"
        exit $EXIT_ERROR
      fi
    fi
    # shellcheck disable=SC2086
    __logger $BSV snapshot -r "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw" "$BSS_SNAP_DEST_BASE/${BSS_SV0}_filter"
    # shellcheck disable=SC2086
    __logger $BSV delete "$BSS_SNAP_DEST_BASE/${BSS_SV0}_rw"
    # remove the original snapshot at last to be safe for normal TYPE without tailing _filter
    if [ "$BSS_SV" = "$BSS_SV0" ]; then
      # shellcheck disable=SC2086
      __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    fi
  fi
}

##############################################################################
__revert() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "R: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  # $1      revert to this SV
  BSS_SV="${1}"
  # sanity check
  if [ "$FS_BASE" = "/" ]; then
    __echo 0 "R: no revert allowed: BASE=$FS_BASE, reboot from a different root filesystem."
    exit $EXIT_ERROR
  fi
  if [ -z "$BSS_SNAP_DEST" ]; then
    __echo 0 "R: no revert supported: BSS_SNAP_DEST_BASE must be defined as non-null string in $BSS_CONF."
    exit $EXIT_ERROR
  fi
  # make last snapshot
  BSS_TYPE="last"
  __snapshot
  __echo 1 "Revert $FS_BASE with $BSS_SNAP_DEST_BASE/$BSS_SV"
  __logger $BSV delete "$FS_BASE"
  __logger $BSV snapshot "$BSS_SNAP_DEST_BASE/$BSS_SV" "$FS_BASE"
}

##############################################################################
__zap() {
  if [ "$FS_TYPE" != "btrfs" ]; then
    __echo 0 "Z: wrong filesystem: FS=$FS_TYPE, BASE=$FS_BASE "
    exit $EXIT_ERROR
  fi
  if [ "$BSS_ZAP_ACTIVE" != "true" ]; then
    __echo 0 "Z: zap operation not allowed since $BSS_CONF at BASE=$FS_BASE has BSS_ZAP_ACTIVE='$BSS_ZAP_ACTIVE'"
    exit $EXIT_ERROR
  fi
  __echo 4 "Z: zap snapshots: BASE=$FS_BASE"
  case "$1" in
  half) # half
    __echo 2 "Zap snapshots into half: BASE=$FS_BASE"
    # search in reverse direction: old -> new
    BSS_LIST="$(__list '.*' -r)"
    BSS_N="$(echo "$BSS_LIST" | wc -w)"
    # count down
    BSS_I="$BSS_N"
    BSS_NH="$(((BSS_N) / 2))"
    if [ "$BSS_NH" -lt "$BSS_NMIN" ]; then
      BSS_NH="$BSS_NMIN"
    fi
    for BSS_SV in $BSS_LIST; do
      BSS_I=$((BSS_I - 1))
      if [ "$BSS_I" -gt "$BSS_NH" ]; then
        __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV"
        # shellcheck disable=SC2086
        __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      else
        __echo 3 "Keep snapshot: BASE=$FS_BASE SV=$BSS_SV"
      fi
    done
    ;;
  new*) # newest
    BSS_SV="$(__list '.*' '-r' | head -n 1)"
    __echo 2 "Del. newest snapshot: BASE=$FS_BASE SV=$BSS_SV"
    # shellcheck disable=SC2086
    __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    ;;
  old*) # oldest
    BSS_SV="$(__list '.*' | head -n 1)"
    __echo 2 "Del. oldest snapshot: BASE=$FS_BASE SV=$BSS_SV"
    # shellcheck disable=SC2086
    __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
    ;;
  *) # labels (local only now)
    __echo 3 "Del. listed snapshots: BASE=$FS_BASE"
    for BSS_SV in "${@}"; do
      BSS_SV="${BSS_SV##*/}"
      if [ -e "$BSS_SNAP_DEST_BASE/$BSS_SV" ]; then
        __echo 2 "Del. snapshot: BASE=$FS_BASE SV=$BSS_SV"
        # shellcheck disable=SC2086
        __logger $BSV delete "$BSS_SNAP_DEST_BASE/$BSS_SV"
      else
        __echo 1 "Missing snapshot to zap: BASE=$FS_BASE SV=$BSS_SV"
      fi
    done
    ;;
  esac
}

##############################################################################
# bss copy FS_BASE0 BSS_COPY_DEST
#   * FS_BASE is obtained from FS_BASE0
#   * BSS_COPY_DEST may have special values: 1, 2, 3
__rsync() {
  # override destination
  if [ -n "$1" ]; then
    BSS_COPY_DEST="$1"
    shift
  fi
  # process aliases
  BSS_COPY_MODE=0
  case $BSS_COPY_DEST in
  1)
    BSS_COPY_DEST="$BSS_COPY_DEST1"
    BSS_COPY_MODE=1
    EXT_COPY_PRE="${EXT_COPY_PRE}1"
    EXT_COPY_POST="${EXT_COPY_POST}1"
    ;;
  2)
    BSS_COPY_DEST="$BSS_COPY_DEST2"
    BSS_COPY_MODE=2
    EXT_COPY_PRE="${EXT_COPY_PRE}2"
    EXT_COPY_POST="${EXT_COPY_POST}2"
    ;;
  3)
    BSS_COPY_DEST="$BSS_COPY_DEST3"
    BSS_COPY_MODE=3
    EXT_COPY_PRE="${EXT_COPY_PRE}3"
    EXT_COPY_POST="${EXT_COPY_POST}3"
    ;;
  esac
  # remove tailing /
  while [ "$BSS_COPY_DEST" = "${BSS_COPY_DEST%/}/" ]; do
    BSS_COPY_DEST="${BSS_COPY_DEST%/}"
  done
  # sanity checks
  if [ -z "$BSS_COPY_DEST" ]; then
    __echo 0 "C: no copy destination given (or was /)"
    exit $EXIT_ERROR
  fi
  if [ "$BSS_COPY_DEST" != "${BSS_COPY_DEST%:*}" ] || \
      [ "$BSS_COPY_DEST" != "${BSS_COPY_DEST%@*}" ]; then
        # remote path (ssh key is in user's home)
    RSYNC="$RSYNC_REMOTE"
    __echo 2 "remote copy destination '$BSS_COPY_DEST'"
    RSYNC_OPTS="$RSYNC_OPTR $CMD_OPTV"
  else
    # BSS_COPY_DEST is local
    RSYNC_OPTS="$RSYNC_OPTA $CMD_OPTV"
    if [ "${BSS_COPY_DEST}" = "${BSS_COPY_DEST#/}" ]; then
      # relative path: (not started with '/')
      BSS_COPY_DEST="$(echo ~)/$BSS_COPY_DEST"
    fi
    if [ ! -e "${BSS_COPY_DEST%/*}" ]; then
      # make parent dir
      $SUDO mkdir -p "${BSS_COPY_DEST%/*}"
    fi
    # Secure BSS_COPY_DEST existence for local absolute path
    if [ ! -e "$BSS_COPY_DEST" ]; then
      if [ "$($SUDO stat -f -c %T "${BSS_COPY_DEST%/*}")" = "btrfs" ]; then
        # parent is btrfs, then subvolume
        $SUDO btrfs subvolume create "$BSS_COPY_DEST"
      else
        $SUDO mkdir -p "$BSS_COPY_DEST"
      fi
    fi
    if [ ! -e "$BSS_COPY_DEST" ]; then
      __echo 0 "C: non-accessible local copy destination '$BSS_COPY_DEST'"
      exit $EXIT_ERROR
    fi
    if [ "$($SUDO stat -f -c %T "$BSS_COPY_DEST")" = "btrfs" ]; then
      if [ "$($SUDO stat -c %i "$FS_BASE")" = "256" ]; then
        # root of btrfs subvolume has always inode number 256
        if [ ! -e "$BSS_COPY_DEST/$BSS_DIR" ]; then
          bss template "$BSS_COPY_DEST" no_filter
        fi
        __echo 2 "local copy destination '$BSS_COPY_DEST' (btrfs)"
      else
        __echo 2 "local copy destination '$BSS_COPY_DEST' (btrfs but not root of btrfs)"
      fi
    else
      __echo 2 "local copy destination '$BSS_COPY_DEST' (non-btrfs)"
    fi
  fi
  #
  if [ -x "$BSS_PRE_COPY_SCRIPT_BASE" ]; then
    __echo 2 "Run $PRE_COPY_SCRIPT before copy for BASE=$FS_BASE FS=$FS_TYPE"
    # shellcheck disable=SC1090
    . "$BSS_PRE_COPY_SCRIPT_BASE" || $BSS_MAY
  fi
  # relaxed rule to allow missing tailing /
  # make snapshot first
  if [ "$FS_TYPE" = "btrfs" ]; then
    # make snapshot
    if [ "$BSS_TYPE" = "single" ]; then
      BSS_TYPE='copy'
    fi
    __snapshot
    __echo 2 "Make copy: BASE=$FS_BASE TIME=${NOW_TSTR} DEST=$BSS_COPY_DEST/ FS=$FS_TYPE"
    # --filter to exclude $BSS directory
    # Hidden undocumented argument handling: $@ (after source)
    # shellcheck disable=SC2086
    __logger $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
      "$BSS_SNAP_DEST_BASE/${NOW_TSTR}.${BSS_TYPE}/" \
      "$BSS_COPY_DEST/" || $BSS_MAY
    # Since this could be slow long process, record ending
    __echo 2 "... Successfully made copy: BASE=$FS_BASE TIME=${NOW_TSTR} DEST=$BSS_COPY_DEST/ FS=$FS_TYPE"
  elif [ "$FS_TYPE" = "ext2/ext3" ]; then
    __echo 2 "Make copy: BASE=$FS_BASE DEST=$BSS_COPY_DEST/ FS=$FS_TYPE "
    # --filter to exclude $BSS directory
    # Hidden undocumented argument handling: $@ (after source)
    # shellcheck disable=SC2086
    __logger $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
      "$FS_BASE/" \
      "$BSS_COPY_DEST/" || $BSS_MAY
    # Since this could be slow long process, record ending
    __echo 2 "... Successfully made copy: BASE=$FS_BASE DEST=$BSS_COPY_DEST/ FS=$FS_TYPE "
  else
    __echo 0 "C: copy for unknown FS=$FS_TYPE requested."
    exit $EXIT_ERROR
  fi
  if [ -x "$BSS_POST_COPY_SCRIPT_BASE" ]; then
    __echo 2 "Run $POST_COPY_SCRIPT after copy for BASE=$FS_BASE FS=$FS_TYPE"
    # shellcheck disable=SC1090
    . "$BSS_POST_COPY_SCRIPT_BASE" || $BSS_MAY
  fi
}
##############################################################################
__rsync_gather_all() {
  if [ -n "${1}" ]; then
    BSS_GATHER="${1}"
  fi
  shift
  BSS_LIST_DIR="${BSS_GATHER}.dir"
  BSS_LIST_DIRRC="${BSS_LIST_DIR}rc"
  BSS_LIST_GPG="${BSS_GATHER}.gpg"
  BSS_LIST_GPGRC="${BSS_LIST_GPG}rc"
  #
  if [ -r "$FS_BASE/$BSS_LIST_DIRRC" ]; then
    __rsync_gather "$FS_BASE/$BSS_LIST_DIRRC" "$FS_BASE/$BSS_LIST_DIR" "$@"
  fi
  if [ -r "$FS_BASE/$BSS_LIST_GPGRC" ]; then
    __rsync_gather "$FS_BASE/$BSS_LIST_GPGRC" "$FS_BASE/$BSS_DIR/$BSS_LIST_GPG" "$@"
    $TAR -c $CMD_OPTV "$FS_BASE/$BSS_DIR/$BSS_LIST_GPG" | \
      $GPG --encrypt > $BSS_LIST_GPG
    $SUDO rm -rf "$FS_BASE/$BSS_DIR/$BSS_LIST_GPG"
  fi
}

__rsync_gather() {
  BSS_GATHER_LIST="$1"
  DEST_DIR_R="$2/root"
  DEST_DIR_H="$2/home"
  shift
  shift
  $SUDO mkdir -p "$DEST_DIR_H"
  $SUDO mkdir -p "$DEST_DIR_R"
  __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $DEST_DIR_H and $DEST_DIR_R"
  # match owner with the parent directory
  __logger $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$DEST_DIR_H"
  __logger $SUDO chmod "$FS_BASE_MOD" "$DEST_DIR_H"
  __logger $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$DEST_DIR_R"
  RSYNC_OPTS="$RSYNC_OPTG $CMD_OPTV"
  # cd to user's home directory
  cd
  __echo 2 "Gather using '$BSS_LIST' to '$FS_BASE/.${BSS_PREFIX}_{root,home}'"
  grep -v -e "^#" "$BSS_GATHER_LIST" | \
    while read -r GATHER_ITEM; do
      # normalize path by removing tailing / or similar
      while true; do
        if [ "$GATHER_ITEM" = "/" ]; then
          break
        elif [ "$GATHER_ITEM" != "${GATHER_ITEM%/..}" ]; then
          # ignore tailing /..
          GATHER_ITEM="${GATHER_ITEM%/..}"
        elif [ "$GATHER_ITEM" != "${GATHER_ITEM%/.}" ]; then
          # ignore tailing /.
          GATHER_ITEM="${GATHER_ITEM%/.}"
        elif [ "$GATHER_ITEM" != "${GATHER_ITEM%/}" ]; then
          # ignore tailing /
          GATHER_ITEM="${GATHER_ITEM%/}"
        else
          break
        fi
      done
      if [ "${GATHER_ITEM}" = "${GATHER_ITEM#/}" ]; then
        # relative path started without /
        DEST_DIR="$DEST_DIR_H/$GATHER_ITEM"
      else
        # absolute path started with /
        DEST_DIR="$DEST_DIR_R$GATHER_ITEM"
      fi
      # --filter to exclude $BSS directory
      # --mkpath to create path $GATHER_ITEM containing / in it
      # Hidden undocumented argument handling: $@ (after source)
      if [ -d "$GATHER_ITEM" ]; then
        __echo 3 "Gather '$GATHER_ITEM/' -> '$DEST_DIR'"
        # shellcheck disable=SC2086
        __logger $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
          $GATHER_ITEM/ "$DEST_DIR" || $BSS_MAY
      else # file, symlink, ...
        __echo 3 "Gather '$GATHER_ITEM' -> '$DEST_DIR'"
        # shellcheck disable=SC2086
        __logger $RSYNC $RSYNC_OPTS --filter "- $BSS_DIR" "$@" \
          $GATHER_ITEM "$DEST_DIR" || $BSS_MAY
      fi
    done
}
##############################################################################
__template_conf_btrfs() {
  __echo 2 "Make configuration $BSS_CONF_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
  $SUDO tee "$BSS_CONF_BASE" >/dev/null <<END_OF_TEMPLATE
# $BSS configuration (btrfs)

# This configuration file as generated by the "template" command.
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#

### Active DATA AGING PARAMETERS
BSS_NMIN="$BSS_NMIN"  # NMIN: minimum items to keep (initial)
BSS_NMAX="$BSS_NMAX"  # NMAX: maximum items to keep (last, if 0, keep all)
BSS_TMAX="$BSS_TMAX"  # TMAX: stop aging, $(age_string $BSS_TMAX)
BSS_TMID="$BSS_TMID"  # TMID: start process, $(age_string $BSS_TMID)
BSS_TMIN="$BSS_TMIN"  # TMIN: start aging, $(age_string $BSS_TMIN)
BSS_STEP="$BSS_STEP"  # STEP: aging step $BSS_STEP %, $(age_string $(($BSS_TMAX * $BSS_STEP / 100))) at BSS_TMAX
BSS_TMAX_ACTION="$BSS_TMAX_ACTION"  # TMAX_ACTION: action at TMAX.  'keep' or 'drop'
BSS_TMID_ACTION="$BSS_TMID_ACTION"  # TMID_ACTION: action at TMID.  'filter' or 'no_filter'
BSS_FMIN="$BSS_FMIN"  # FMIN: minimum required free disk % for snapshot

### Baseline DATA AGING PARAMETERS
## BSS_NMIN="$BSS_NMIN"  # NMIN: minimum items to keep (initial)
## BSS_NMAX="$BSS_NMAX"  # NMAX: maximum items to keep (last, if 0, keep all)
## BSS_TMAX="$BSS_TMAX"  # TMAX: stop aging, $(age_string $BSS_TMAX)
## BSS_TMID="$BSS_TMID"  # TMID: start process, $(age_string $BSS_TMID)
## BSS_TMIN="$BSS_TMIN"  # TMIN: start aging, $(age_string $BSS_TMIN)
## BSS_STEP="$BSS_STEP"  # STEP: aging step $BSS_STEP %, $(age_string $(($BSS_TMAX * $BSS_STEP / 100))) at BSS_TMAX
## BSS_TMAX_ACTION="$BSS_TMAX_ACTION"  # TMAX_ACTION: action at TMAX.  'keep' or 'drop'
## BSS_TMID_ACTION="$BSS_TMID_ACTION"  # TMID_ACTION: action at TMID.  'filter' or 'no_filter'
## BSS_FMIN="$BSS_FMIN"  # FMIN: minimum required free disk % for snapshot

## Following parameters defines the aging behavior.
##
## * BSS_NMAX:
##   maximum number of snapshots to keep If this is set to 0, no limit on number
##   of snapshots
## * BSS_NMIN:
##   number of initial snapshots to keep unconditionally
## * BSS_STEP:
##   This parameter defines the rule to drop snapshots for aging.  If the age of a
##   snapshot is BSS_STEP % less than the age of the last kept snapshot, such a
##   snapshot is dropped.
## * BSS_TMAX:
##   If the age of a snapshot is older than BSS_TMAX, aging rule based on BSS_STEP
##   is disabled.  BSS_TMAX=0 means no age check for TMAX (no_limit).
## * BSS_TMID:
##   If the age of a snapshot is older than BSS_TMID, snapshots with type 'post' are
##   dropped and other snapshots are aged using BSS_STEP.  If filter is active,
##   snapshots are filtered.
## * BSS_TMIN:
##   If the age of a snapshot is older than BSS_TMIN, snapshots with type 'post' are
##   dropped, snapshots with type 'single' and 'hour' are aged using BSS_STEP,
##   snapshots with type 'boot', and 'pre' are kept unconditionally.
## * BSS_TMAX_ACTION:
##   Determine the action at TMAX.  Default is 'keep'.  Set this to 'drop' to
##   remove snapshots at TMAX.
## * BSS_TMID_ACTION:
##   Determine the action at TMID.  Default for the normal data filesystem is
##   'no_filter'.  Set this to 'filter' to activate filter to reduce remote backup
##   size.
## * BSS_FMIN:
##   If the number of free disk blocks is smaller than BSS_FMIN % of the total
##   number of disk blocks, the snapshot operation will fail to avoid filling
##   up the disk.

### EXTRA PARAMETERS ###

# safety (change this if you want to disable some zap operations)
BSS_ZAP_ACTIVE="true"

# convenience for "$BSS copy".  Set this to non-zero string to activate default destination.
BSS_COPY_DEST=""
# convenience for "$BSS copy".  Use this when destination is "1" ("1" works as alias).
BSS_COPY_DEST1=""
# convenience for "$BSS copy".  Use this when destination is "2" ("2" works as alias).
BSS_COPY_DEST2=""
# convenience for "$BSS copy".  Use this when destination is "3" ("3" works as alias).
BSS_COPY_DEST3=""

# For normal mode, keep BSS_SNAP_DEST as null sting.
# For system snapshot mode (an enhancement for "$BSS snapshot"), set
# BSS_SNAP_DEST to non-zero string "<offset_path>" pointing to an absolute path
# to activate the non-default destination for the btrfs snapshot accessible
# only from outside of the original filesystem.
BSS_SNAP_DEST=""

### NOTE ###

# You can add a custom script to filter contents at TMID as $BSS_FLTR in this directory
# You can add a custom script to run before copy as $PRE_COPY_SCRIPT in this directory
# You can add a custom script to run after copy as $POST_COPY_SCRIPT in this directory
# If BSS_COPY_DEST aliases 1,2,3 are used, script name to use should be suffixed accordingly.

# Many internal variables are prefixed with 'BSS_' to be unique to "$BSS" but
# the dialog messages may just use the rest of variable name to be concise.
END_OF_TEMPLATE
}
##############################################################################
__template_conf_non_btrfs() {
  __echo 2 "Make configuration $BSS_CONF_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
  $SUDO tee "$BSS_CONF_BASE" >/dev/null <<END_OF_TEMPLATE
# $BSS configuration (non-btrfs)

# This configuration file as generated by the "template" command.
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
# FS=$FS_TYPE
#

### EXTRA PARAMETERS ###

# convenience for "$BSS copy".  Set this to non-zero string to activate default destination.
BSS_COPY_DEST=""
# convenience for "$BSS copy".  Use this when destination is "1" ("1" works as alias).
BSS_COPY_DEST1=""
# convenience for "$BSS copy".  Use this when destination is "2" ("2" works as alias).
BSS_COPY_DEST2=""
# convenience for "$BSS copy".  Use this when destination is "3" ("3" works as alias).
BSS_COPY_DEST3=""

### NOTE ###

# You can add a custom script to filter contents at TMID as $BSS_FLTR in this directory
# You can add a custom script to run before copy as $PRE_COPY_SCRIPT in this directory
# You can add a custom script to run after copy as $POST_COPY_SCRIPT in this directory
# If BSS_COPY_DEST aliases 1,2,3 are used, script name to use should be suffixed accordingly.

# Many internal variables are prefixed with 'BSS_' to be unique to "$BSS" but
# the dialog messages may just use the rest of variable name to be concise.
END_OF_TEMPLATE
}
##############################################################################
__template_filter_root() {
  __echo 2 "Make filter $BSS_FLTR_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
  $SUDO tee "$BSS_FLTR_BASE" >/dev/null <<END_OF_TEMPLATE
# $BSS filter (better to use relative path)
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#
# Running filter drains CPU and SSD resources but it may save SSD usage size
# significantly.  If you are not interested in reducing SSD usage size by this
# script, remove this file and set BSS_TMID_ACTION="no_filter" in "$BSS_CONF"
#
# This is intended as template file.  As provided, this removes many
# non-administrator generated files to reduce disk usage size significantly.
# Edit this to your taste and set BSS_TMID_ACTION="filter" in "$BSS_CONF" to
# use this filter.  Otherwise remove this file and set
# BSS_TMID_ACTION="no_filter" in "$BSS_CONF".
#
### Remove all files under /tmp
rm -rf tmp var/tmp

### Remove most files under /var
rm -rf var/cache var/log var/spool var/lib/apt

### Remove /usr excluding /usr/local
find usr -maxdepth 1 -mindepth 1 -type d ! -name local -exec rm -rf '{}' +

### Remove very old kernel and initrd in /boot
find boot -type f -name 'initrd*' -exec rm -rf '{}' \;
find boot -type f -name 'vmlinu*' -exec rm -rf '{}' \;

END_OF_TEMPLATE
}
##############################################################################
__template_filter_non_root() {
  __echo 2 "Make filter $BSS_FLTR_BASE for BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID"
  $SUDO tee "$BSS_FLTR_BASE.disabled" >/dev/null <<END_OF_TEMPLATE
# $BSS filter (better to use relative path)
#
# BASE=$FS_BASE UID=$FS_BASE_UID GID=$FS_BASE_GID
#
# Running filter drains CPU and SSD resources but it may save SSD usage size
# significantly.
#
# If you are not interested in reducing SSD usage size by this script, keep
# this file as $BSS_FLTR_BASE.disabled and set BSS_TMID_ACTION="no_filter" in
# "$BSS_CONF".
#
# If you are interested in reducing SSD usage size by this script, rename this
# file from $BSS_FLTR_BASE.disabled to $BSS_FLTR_BASE and set
# BSS_TMID_ACTION="filter" in "$BSS_CONF".
#
###### Example for <user> subvolume at FS_BASE=/home/<user>

### Trace filter execution
#set -x

### Remove all files under .cache
#rm -rf .cache

### Remove huge (>20 MB) files (mostly iso, tar.gz, ...)
#find . -type f -size +20M ! -iname '*.mov' -delete

### Remove core files
#find . -type f -name core -delete

### Remove old .git/ directory contents ('-depth' is needed to avoid error message)
#find . -depth -type d -name '.git' -exec rm -rf '{}' \;

END_OF_TEMPLATE
}

##############################################################################
__template() {
  # make sure $BSS_DIR_BASE exists
  if [ ! -d "$BSS_DIR_BASE" ]; then
    if [ -z "$BSS_NOOP" ]; then
      __logger $SUDO mkdir -p "$BSS_DIR_BASE"
      # match owner with the parent directory
      __logger $SUDO chown "$FS_BASE_UID":"$FS_BASE_GID" "$BSS_DIR_BASE"
      __logger $SUDO chmod "$FS_BASE_MOD" "$BSS_DIR_BASE"
    else
      __echo 0 "T: '$BSS template' must not be used with --noop nor -n option."
      exit $EXIT_ERROR
    fi
  fi
  ############################################################################
  #
  # conf and filter template
  #
  ############################################################################
  #
  if [ "$FS_TYPE" = "btrfs" ]; then
    ### CONFIGURATION ###
    #
    if [ -e "$BSS_CONF_BASE" ]; then
      __echo 1 "Configuration file already exists: $BSS_CONF for BASE=$FS_BASE, keep it as is."
      __echo 2 "Loading existing $BSS_CONF for BASE=$FS_BASE."
      __load_config
    else
      if [ "$FS_BASE" = "/" ]; then
        BSS_TMID_ACTION="filter"
        __echo 2 "Suggest BSS_TMID_ACTION=\"filter\" in template since BASE=$FS_BASE (full system)"
      else
        BSS_TMID_ACTION="no_filter"
      fi
      __template_conf_btrfs
      __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_CONF_BASE"
      # shellcheck disable=SC2086
      __logger $SUDO chown "$FS_BASE_UID:$FS_BASE_GID" "$BSS_CONF_BASE"
    fi
    #
    ### FILTER ###
    #
    #
    if [ "$FS_BASE" = "/" ]; then
      if [ -e "$BSS_FLTR_BASE" ]; then
        __echo 1 "Filter file already exists: $BSS_FLTR for BASE=$FS_BASE, keep it as is."
      elif [ -e "$BSS_FLTR_BASE.disabled" ]; then
        __echo 1 "Filter placeholder file already exists: $BSS_FLTR.disabled for BASE=$FS_BASE, keep it as is."
      else
        __template_filter_root
        __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_FLTR_BASE"
        # shellcheck disable=SC2086
        __logger $SUDO chown $FS_BASE_UID:$FS_BASE_GID "$BSS_FLTR_BASE"
      fi
    else
      if [ -e "$BSS_FLTR_BASE" ]; then
        __echo 1 "Filter file already exists: $BSS_FLTR for BASE=$FS_BASE, keep it as is."
      elif [ -e "$BSS_FLTR_BASE.disabled" ]; then
        __echo 1 "Filter placeholder file already exists: $BSS_FLTR.disabled for BASE=$FS_BASE, keep it as is."
      else
        __template_filter_non_root
        __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_FLTR_BASE.disabled"
        # shellcheck disable=SC2086
        __logger $SUDO chown $FS_BASE_UID:$FS_BASE_GID "$BSS_FLTR_BASE.disabled"
      fi
    fi
    if [ "$BSS_TMID_ACTION" != "filter" ] && [ -e "$BSS_FLTR_BASE" ]; then
      __echo 2 "Please reconcile settings."
      __echo 2 " * Update $BSS_CONF to set MID_ACTION='filter' to use $BSS_FLTR."
      __echo 2 " * Keep $BSS_CONF to set MID_ACTION='no_filter' and rename from $BSS_FLTR to $BSS_FLTR.disabled."
    fi
  else # non-btrfs
    if [ -e "$BSS_CONF_BASE" ]; then
      __echo 1 "Configuration file already exists: $BSS_CONF for BASE=$FS_BASE, keep it as is."
      __echo 2 "Loading existing $BSS_CONF for BASE=$FS_BASE."
    else
      __template_conf_non_btrfs
      __echo 3 "Set owner to $FS_BASE_UID:$FS_BASE_GID for $BSS_CONF_BASE and $BSS_FLTR_BASE"
      # shellcheck disable=SC2086
      __logger $SUDO chown $FS_BASE_UID:$FS_BASE_GID "$BSS_CONF_BASE"
    fi
  #
  fi
}

##############################################################################
__batch() {
  if [ "$(id -u)" = 0 ]; then
    CONFIG_BSS="/etc/bss"
    mkdir -p "$CONFIG_BSS"
    chmod 755 "$CONFIG_BSS"
  else
    if [ -n "$XDG_CONFIG_HOME" ]; then
      CONFIG_BSS="${XDG_CONFIG_HOME}/bss"
    else
      CONFIG_BSS="$(echo ~)/.config/bss"
    fi
    mkdir -p "$CONFIG_BSS"
    chmod 755 "$CONFIG_BSS"
  fi
  if [ -z "$1" ]; then
    BSS_BATCH_FILE="$CONFIG_BSS/default"
    if [ ! -r "$BSS_BATCH_FILE" ]; then
      __echo 0 "B: please specify existing file in $CONFIG_BSS"
      exit 1
    fi
  else
    BSS_BATCH_FILE="$CONFIG_BSS/${1}"
    if [ ! -r "$BSS_BATCH_FILE" ]; then
      __echo 0 "B: $BSS_BATCH_FILE is unreadable."
      __echo 0 "B: please specify existing file in $CONFIG_BSS: BSS_BATCH_FILE=$BSS_BATCH_FILE"
      exit 1
    fi
  fi
  # export
  export BSS_NOOP
  export BSS_LOGGER_JOURNAL
  export BSS_LOGGER_LEVEL
  export BSS_TYPE
  export BSS_MAY
  # simply source $BSS_BATCH_FILE: ~/.config/bss/<specified>
  . "$BSS_BATCH_FILE" || "$BSS_MAY"
}
##############################################################################
# Parse Command Line
##############################################################################
# The quotes around "$@" are essential!
# We need TEMP as the 'eval set --' would nuke the return value of getopt.
TEMP=$(getopt -o 't:c:s:fmnqvxhlL' -n "${BSS}" \
  --long 'type:,config:,snap:,force,may,noop,quiet,version,verbose,trace,help,logger,nologger' -- "$@")
# Note the quotes around "$TEMP": they are essential!
#echo "DEBUG: ***** TEMP='$TEMP'"
eval set -- "$TEMP"
unset TEMP
# The above reorder all options before subcommands
# OPTIONS
while [ -n "$1" ]; do
  case "$1" in
  -t | --type)
    shift
    BSS_TYPE="$1"
    ;;
  -c | --config)
    shift
    BSS_STEM="$1"
    ;;
  -f | --force)
    BSS_FORCE="FORCE"
    ;;
  -m | --may)
    BSS_MAY="true"
    ;;
  -n | --noop)
    BSS_NOOP="echo __" # ANY non ""
    ;;
  -q | --quiet)
    BSS_LOGGER_LEVEL=1
    ;;
  --version)
    __version
    exit $EXIT_SUCCESS
    ;;
  -v | --verbose)
    BSS_LOGGER_LEVEL=$((BSS_LOGGER_LEVEL + 1))
    ;;
  -x | --trace)
    SETX_ON="set -x"
    SETX_OFF="set +x"
    ;;
  -h | --help)
    __help
    exit $EXIT_SUCCESS
    ;;
  -l | --logger)
    # force to enable the systemd journal
    BSS_LOGGER_JOURNAL=1
    ;;
  -L | --nologger)
    # force to disable the systemd journal
    BSS_LOGGER_JOURNAL=0
    ;;
  '--')
    shift
    break
    ;;
  *)
    break
    ;;
  esac
  shift
done
# update parameters for -c
BSS_CONF="$BSS_STEM.$EXT_CONF"
BSS_FLTR="$BSS_STEM.$EXT_FLTR"
PRE_COPY_SCRIPT="$BSS_STEM.$EXT_COPY_PRE"
POST_COPY_SCRIPT="$BSS_STEM.$EXT_COPY_POST"
$SETX_ON
##############################################################################
# find the BASE path of btrfs: FS_BASE, '$1' consumed
##############################################################################
if [ -z "$1" ]; then
  BSS_COMMAND="snapshot"
else
  BSS_COMMAND="$1"
  shift
fi
# execute subcommands without PATH argument
case "$BSS_COMMAND" in
j*) # jobs
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __jobs
  exit $EXIT_SUCCESS
  ;;
b*) # batch (Always change PWD to ~/)
  cd "$(echo ~)"
  # batch mode: systend logger ON as default
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  BSS_LOGGER_TERMINAL=0
  __batch "$@"
  exit $EXIT_SUCCESS
  ;;
esac
# set FS_BASE etc.
if [ "$BSS_COMMAND" = "zap" ] || [ -z "$1" ]; then
  # FS_BASE0: current path
  FS_BASE0=$($SUDO realpath ".")
else
  FS_BASE0=$($SUDO realpath "${1}")
  shift
fi
# Set FS_BASE
__set_fs_base
# execute subcommands with PATH argument
case "$BSS_COMMAND" in
s*) #snapshot
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __snapshot
  ;;
a*) # assess aging status and report age data lines to STDOUT
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __load_config
  __age
  ;;
o*) # overview (for human check)
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __load_config
  # Logging outputs use STDERR, drop normal __age outputs to STDOUT
  BSS_LOGGER_LEVEL=3
  __age >/dev/null
  ;;
p*) # process
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __process
  ;;
c*) # copy
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __rsync "$@"
  ;;
l*) # list (report match in STDOUT)
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __load_config
  if [ -z "$1" ]; then
    __list '.*'
  else
    __list "$1" "$2" "$3"
  fi
  ;;
g*) # gather
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __rsync_gather "$@"
  ;;
f*) # filter
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __filter "$1"
  ;;
r*) # revert
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __revert "$1"
  ;;
zap) # zap
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=1
  fi
  __load_config
  __zap "$@"
  ;;
t*) # template
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __template "$@"
  ;;
B*) # BASE (interactive use only)
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  echo "$FS_BASE"
  ;;
*) # unknown
  if [ "$BSS_LOGGER_JOURNAL" = "-1" ]; then
    BSS_LOGGER_JOURNAL=0
  fi
  __echo 0 "Unknown command: '$*'   ---   See more 'bss --help'"
  exit $EXIT_ERROR
  ;;
esac
# Normal case
exit $EXIT_SUCCESS
